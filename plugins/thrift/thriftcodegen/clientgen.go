package thriftcodegen

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/blueprint-uservices/blueprint/plugins/golang"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gocode"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gogen"
	"golang.org/x/exp/slog"
)

// This function is used by the Thrift plugin to generate the client-side caller of the Thrift service.
//
// It is assumed that outputPackage is the same as the one where the .thrift is generated to
func GenerateClient(builder golang.ModuleBuilder, service *gocode.ServiceInterface, outputPackage string) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	innerPkg := strings.ToLower(service.BaseName)

	client := &clientArgs{
		Package:      pkg,
		Service:      service,
		Name:         service.BaseName + "_ThriftClient",
		Imports:      gogen.NewImports(pkg.Name),
		ImportPrefix: innerPkg,
	}

	innerPkgPath := builder.Info().Name + "/" + outputPackage + "/" + innerPkg

	client.Imports.AddPackages(
		"context", "time", "errors",
		"github.com/apache/thrift/lib/go/thrift",
		innerPkgPath,
	)

	slog.Info(fmt.Sprintf("Generating %v/%v.go", client.Package.PackageName, client.Name))
	outputFile := filepath.Join(client.Package.Path, client.Name+".go")
	return gogen.ExecuteTemplateToFile("ThriftClient", clientTemplate, client, outputFile)
}

// Arguments to the template code
type clientArgs struct {
	Package      golang.PackageInfo
	Service      *gocode.ServiceInterface
	Name         string
	Imports      *gogen.Imports
	ImportPrefix string
}

var clientTemplate = `// Blueprint: Auto-generated by Thrift Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	{{.Imports.NameOf .Service.UserType}}
	Client *{{.ImportPrefix}}.{{.Service.BaseName}}Client // The actual thrift-generated client
	Timeout time.Duration
	Address string
}

func New_{{.Name}}(ctx context.Context, serverAddress string) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Address = serverAddress
	var protocolFactory thrift.TProtocolFactory
	protocolFactory = thrift.NewTBinaryProtocolFactory(true, true)
	var transportFactory thrift.TTransportFactory
	transportFactory = thrift.NewTTransportFactory()
	var transport thrift.TTransport
	var err error
	duration, err := time.ParseDuration("1s")
	if err != nil {
		return nil, err
	}
	transport, err = thrift.NewTSocketTimeout(handler.Address, duration, duration)
	if err != nil {
		return nil, err
	}
	transport, err = transportFactory.GetTransport(transport)
	if err != nil {
		return nil, err
	}
	err = transport.Open()
	if err != nil {
		return nil, err
	}
	iprot := protocolFactory.GetProtocol(transport)
	oprot := protocolFactory.GetProtocol(transport)

	client := {{.ImportPrefix}}.New{{.Service.BaseName}}Client(thrift.NewTStandardClient(iprot, oprot))
	handler.Client = client
	handler.Timeout = duration
	return handler, nil
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{$prefix := .ImportPrefix -}}
{{- range $_, $f := .Service.Methods }}
func (client *{{$receiver}}) {{SignatureWithRetVars $f}} {
	// Create and marshall the thrift Request object
	req := &{{$prefix}}.{{$service}}_{{$f.Name}}_Request{}
	marshall_{{$f.Name}}_req(req, {{ArgVars $f}})

	ctx, cancel := context.WithTimeout(ctx, client.Timeout)
	defer cancel()

	rsp, err := client.Client.{{$f.Name}}(ctx, req)
	if err != nil {
		err = ctx.Err()
	}
	if err != nil {
		return
	}
	if rsp == nil {
		err = errors.New("Response object is nil")
		return
	}

	{{RetVarsEquals $f}} unmarshall_{{$f.Name}}_rsp(rsp)
	return
}
{{end}}
`
