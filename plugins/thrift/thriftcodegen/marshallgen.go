package thriftcodegen

import (
	"fmt"
	"strings"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/blueprint"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
)

type marshallArgs struct {
	ThriftBuilder
	Imports *gogen.Imports
}

func (b *ThriftBuilder) GenerateMarshallingCode(outputFilePath string) error {
	args := &marshallArgs{}
	args.ThriftBuilder = *b
	args.Imports = gogen.NewImports(args.PackageName)

	for _, struc := range args.ThriftBuilder.Structs {
		for _, field := range struc.FieldList {
			args.Imports.AddType(field.SrcType)
		}
	}

	return gogen.ExecuteTemplateToFile("marshallThrift", marshallTemplate, args, outputFilePath)
}

var marshallTemplate = `// Blueprint: Auto-generated by Thrift Plugin marshallgen.go
package {{.Package}}

{{.Imports}}

{{$imports := .Imports -}}
{{ range $_1, $service := .Services -}}
{{ range $_2, $method := $service.Methods -}}
// Client-side function to pack {{$service.Name}}.{{$method.Name}} args into a GRPC {{$method.Request.ThriftType.Name}} struct
func marshall_{{$method.Name}}_req({{$method.MarshallRequest $imports}}) *{{$method.Request.ThriftType.Name}} {
	{{- range $j, $arg := $method.Request.FieldList}}
	{{$arg.Marshall $imports ""}}
	{{- end}}
	return msg
}

// Server-side function to unpack {{$service.Name}}.{{$method.Name}} args from a GRPC {{$method.Request.ThriftType.Name}} struct
func unmarshall_{{$method.Name}}_req(msg *{{$method.Request.ThriftType.Name}}) (
	{{- range $j, $arg := $method.Request.FieldList}}{{if $j}}, {{end}}{{$arg.Name}} {{$imports.NameOf $arg.SrcType}}{{end -}}
) {
	{{- range $j, $arg := $method.Request.FieldList}}
	{{$arg.Unmarshall $imports ""}}
	{{- end}}
	return
}

// Server-side function to pack {{$service.Name}}.{{$method.Name}} retvals into a GRPC {{$method.Response.ThriftType.Name}} struct
func marshall_{{$method.Name}}_rsp({{$method.MarshallResponse $imports}}) *{{$method.Response.ThriftType.Name}} {
	{{- range $j, $ret := $method.Response.FieldList}}
	{{$ret.Marshall $imports ""}}
	{{- end}}
	return msg
}

// Client-side function to unpack {{$service.Name}}.{{$method.Name}} retvals from a GRPC {{$method.Response.ThriftType.Name}} struct
func unmarshall_{{$method.Name}}_rsp(msg *{{$method.Response.ThriftType.Name}}) (
	{{- range $j, $ret := $method.Response.FieldList}}{{if $j}}, {{end}}{{$ret.Name}} {{$imports.NameOf $ret.SrcType}}{{end -}}
) {
	{{- range $j, $ret := $method.Response.FieldList}}
	{{$ret.Unmarshall $imports ""}}
	{{- end}}
	return
}

{{end -}}
{{end -}}

{{ range $t, $struct := .GoStructs}}
// Utility function to pack {{$imports.Qualify $t.Package $t.Name}} into a Thrift {{$struct.ThriftType.Name}} struct
func (msg *{{$struct.ThriftType.Name}}) marshall(obj *{{$imports.Qualify $t.Package $t.Name}}) *{{$struct.ThriftType.Name}} {
	{{- range $j, $field := $struct.FieldList}}
	{{$field.Marshall $imports "obj."}}
	{{- end}}
	return msg
}

// Utility function to unpack {{$imports.Qualify $t.Package $t.Name}} from a Thrift {{$struct.ThriftType.Name}} struct
func (msg *{{$struct.ThriftType.Name}}) unmarshall(obj *{{$imports.Qualify $t.Package $t.Name}}) {
	{{- range $j, $field := $struct.FieldList}}
	{{$field.Unmarshall $imports "obj."}}
	{{- end}}
}
{{end}}
`

func (m *ThriftMethodDecl) MarshallRequest(imports *gogen.Imports) (string, error) {
	var fields []string
	fields = append(fields, "msg *"+m.Request.ThriftType.Name)
	for _, field := range m.Request.FieldList {
		fieldType := imports.NameOf(field.SrcType)
		field_string := field.Name + " " + fieldType
		fields = append(fields, field_string)
	}
	s := strings.Join(fields, ", ")
	return s, nil
}

func (m *ThriftMethodDecl) MarshallResponse(imports *gogen.Imports) (string, error) {
	var fields []string
	fields = append(fields, "msg *"+m.Response.ThriftType.Name)
	for _, field := range m.Response.FieldList {
		fieldType := imports.NameOf(field.SrcType)
		field_string := field.Name + " " + fieldType
		fields = append(fields, field_string)
	}
	s := strings.Join(fields, ", ")
	return s, nil
}

func (f *ThriftField) Marshall(imports *gogen.Imports, obj string) (string, error) {
	switch t := f.ThriftGoType.(type) {
	case *gocode.UserType:
		{
			return fmt.Sprintf("msg.%s = new(%s).marshall(&%s%s)", strings.Title(f.Name), t.Name, obj, f.Name), nil
		}
	case *gocode.BasicType:
		{
			return fmt.Sprintf("msg.%s = %s(%s%s)", strings.Title(f.Name), t.Name, obj, f.Name), nil
		}
	case *gocode.Pointer:
		{
			switch pt := t.PointerTo.(type) {
			case *gocode.UserType:
				return fmt.Sprintf("msg.%s = new(%s).marshall(%s%s)", strings.Title(f.Name), pt.Name, obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s(*%s%s)", strings.Title(f.Name), pt.Name, obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported pointer type %v", pt)
			}
		}
	case *gocode.Map:
		{
			switch vt := t.ValueType.(type) {
			case *gocode.UserType:
				{
					return fmt.Sprintf(`
    msg.%s = make(map[%s]*%s)
	for k, v := range %s%s {
		msg.%s[k] = new(%s).marshall(&v)
	}`, strings.Title(f.Name), t.KeyType, vt.Name, obj, f.Name, strings.Title(f.Name), vt.Name), nil
				}
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented map value type %v", vt)
			}
		}
	case *gocode.Slice:
		{
			switch st := t.SliceOf.(type) {
			case *gocode.UserType:
				return fmt.Sprintf(
					"for _, v := range %s%s { msg.%s = append(msg.%s, new(%s).marshall(&v)) }",
					obj, f.Name, strings.Title(f.Name), strings.Title(f.Name), st.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented slice type %v", st)
			}
		}
	}
	return "", nil
}

func (f *ThriftField) Unmarshall(imports *gogen.Imports, obj string) (string, error) {
	switch t := f.ThriftGoType.(type) {
	case *gocode.UserType:
		{
			return fmt.Sprintf("msg.%s.unmarshall(&%s%s)", strings.Title(f.Name), obj, f.Name), nil
		}
	case *gocode.BasicType:
		{
			return fmt.Sprintf("%s%s = %v(msg.%s)", obj, f.Name, f.SrcType, strings.Title(f.Name)), nil
		}
	case *gocode.Pointer:
		{
			switch pt := t.PointerTo.(type) {
			case *gocode.UserType:
				return fmt.Sprintf("msg.%s.unmarshall(%s%s)", strings.Title(f.Name), obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("%s%s = &%v(msg.%s)", obj, f.Name, f.SrcType, strings.Title(f.Name)), nil
			default:
				return "", blueprint.Errorf("unsupported pointer type %v", pt)
			}
		}
	case *gocode.Map:
		{
			switch t.ValueType.(type) {
			case *gocode.UserType:
				{
					return fmt.Sprintf(`
    %s%s = make(%s)
	for k, v := range msg.%s {
		objv := %s%s[k]
		v.unmarshall(&objv)
	}`, obj, f.Name, imports.NameOf(f.SrcType), strings.Title(f.Name), obj, f.Name), nil
				}
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported map value type %v", t)
			}
		}
	case *gocode.Slice:
		{
			switch st := t.SliceOf.(type) {
			case *gocode.UserType:
				return fmt.Sprintf(`
	%s%s = make(%s, len(msg.%s))
	for i, v := range msg.%s {
		v.unmarshall(&%s%s[i])
	}`, obj, f.Name, imports.NameOf(f.SrcType), strings.Title(f.Name), strings.Title(f.Name), obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("%s%s = msg.%s", obj, f.Name, strings.Title(f.Name)), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented slice type %v", st)
			}
		}
	}
	return "", nil
}
