package thriftcodegen

import (
	"fmt"
	"strings"

	"github.com/blueprint-uservices/blueprint/blueprint/pkg/blueprint"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gocode"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gogen"
)

type marshallArgs struct {
	ThriftBuilder
	Imports *gogen.Imports
}

// Generates marshalling functions that convert between Go objects and Thrift struct objects
//
// This extends the code in thriftgen.go and is called from thriftgen.go
func (b *ThriftBuilder) GenerateMarshallingCode(outputFilePath string) error {
	args := &marshallArgs{}
	args.ThriftBuilder = *b
	args.Imports = gogen.NewImports(args.PackageName)

	for _, struc := range args.ThriftBuilder.Structs {
		for _, field := range struc.FieldList {
			args.Imports.AddType(field.SrcType)
		}
	}

	args.Imports.AddPackages(b.InternalPkg)

	return gogen.ExecuteTemplateToFile("marshallThrift", marshallTemplate, args, outputFilePath)
}

var marshallTemplate = `// Blueprint: Auto-generated by Thrift Plugin marshallgen.go
package {{.Package}}

{{.Imports}}

{{$imports := .Imports -}}
{{$pkg := .ImportName}}
{{ range $_1, $service := .Services -}}
{{ range $_2, $method := $service.Methods -}}
// Client-side function to pack {{$service.Name}}.{{$method.Name}} args into a Thrift {{$pkg}}.{{$method.Request.ThriftType.Name}} struct
func marshall_{{$method.Name}}_req({{$method.MarshallRequest $imports $pkg}}) *{{$pkg}}.{{$method.Request.ThriftType.Name}} {
	{{- range $j, $arg := $method.Request.FieldList}}
	{{$arg.Marshall $imports "" $pkg}}
	{{- end}}
	return msg
}

// Server-side function to unpack {{$service.Name}}.{{$method.Name}} args from a Thrift {{$method.Request.ThriftType.Name}} struct
func unmarshall_{{$method.Name}}_req(msg *{{$pkg}}.{{$method.Request.ThriftType.Name}}) (
	{{- range $j, $arg := $method.Request.FieldList}}{{if $j}}, {{end}}{{$arg.Name}} {{$imports.NameOf $arg.SrcType}}{{end -}}
) {
	{{- range $j, $arg := $method.Request.FieldList}}
	{{$arg.Unmarshall $imports "" $pkg}}
	{{- end}}
	return
}

// Server-side function to pack {{$service.Name}}.{{$method.Name}} retvals into a Thrift {{$pkg}}.{{$method.Response.ThriftType.Name}} struct
func marshall_{{$method.Name}}_rsp({{$method.MarshallResponse $imports $pkg}}) *{{$pkg}}.{{$method.Response.ThriftType.Name}} {
	{{- range $j, $ret := $method.Response.FieldList}}
	{{$ret.Marshall $imports "" $pkg}}
	{{- end}}
	return msg
}

// Client-side function to unpack {{$service.Name}}.{{$method.Name}} retvals from a Thrift {{$method.Response.ThriftType.Name}} struct
func unmarshall_{{$method.Name}}_rsp(msg *{{$pkg}}.{{$method.Response.ThriftType.Name}}) (
	{{- range $j, $ret := $method.Response.FieldList}}{{if $j}}, {{end}}{{$ret.Name}} {{$imports.NameOf $ret.SrcType}}{{end -}}
) {
	{{- range $j, $ret := $method.Response.FieldList}}
	{{$ret.Unmarshall $imports "" $pkg}}
	{{- end}}
	return
}

{{end -}}
{{end -}}

{{$pkg := .ImportName}}
{{ range $t, $struct := .GoStructs}}
// Utility function to pack {{$imports.Qualify $t.Package $t.Name}} into a Thrift {{$struct.ThriftType.Name}} struct
func marshall_{{$pkg}}_{{$struct.ThriftType.Name}}(msg *{{$pkg}}.{{$struct.ThriftType.Name}}, obj *{{$imports.Qualify $t.Package $t.Name}}) *{{$pkg}}.{{$struct.ThriftType.Name}} {
	{{- range $j, $field := $struct.FieldList}}
	{{$field.Marshall $imports "obj." $pkg}}
	{{- end}}
	return msg
}

// Utility function to unpack {{$imports.Qualify $t.Package $t.Name}} from a Thrift {{$struct.ThriftType.Name}} struct
func unmarshall_{{$pkg}}_{{$struct.ThriftType.Name}}(msg *{{$pkg}}.{{$struct.ThriftType.Name}}, obj *{{$imports.Qualify $t.Package $t.Name}}) {
	{{- range $j, $field := $struct.FieldList}}
	{{$field.Unmarshall $imports "obj." $pkg}}
	{{- end}}
}
{{end}}
`

func (m *ThriftMethodDecl) MarshallRequest(imports *gogen.Imports, pkg string) (string, error) {
	var fields []string
	fields = append(fields, "msg *"+pkg+"."+m.Request.ThriftType.Name)
	for _, field := range m.Request.FieldList {
		fieldType := imports.NameOf(field.SrcType)
		field_string := field.Name + " " + fieldType
		fields = append(fields, field_string)
	}
	s := strings.Join(fields, ", ")
	return s, nil
}

func (m *ThriftMethodDecl) MarshallResponse(imports *gogen.Imports, pkg string) (string, error) {
	var fields []string
	fields = append(fields, "msg *"+pkg+"."+m.Response.ThriftType.Name)
	for _, field := range m.Response.FieldList {
		fieldType := imports.NameOf(field.SrcType)
		field_string := field.Name + " " + fieldType
		fields = append(fields, field_string)
	}
	s := strings.Join(fields, ", ")
	return s, nil
}

func (f *ThriftField) Marshall(imports *gogen.Imports, obj string, pkg string) (string, error) {
	switch t := f.ThriftGoType.(type) {
	case *gocode.UserType:
		{
			return fmt.Sprintf("msg.%s = marshall_%s_%s(new(%s.%s), &%s%s)", strings.Title(f.Name), pkg, t.Name, pkg, t.Name, obj, f.Name), nil
		}
	case *gocode.BasicType:
		{
			return fmt.Sprintf("msg.%s = %s(%s%s)", strings.Title(f.Name), t.Name, obj, f.Name), nil
		}
	case *gocode.Pointer:
		{
			switch pt := t.PointerTo.(type) {
			case *gocode.UserType:
				return fmt.Sprintf("msg.%s = marshall_%s_%s(new(%s.%s),%s%s)", strings.Title(f.Name), pkg, pt.Name, pkg, pt.Name, obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s(*%s%s)", strings.Title(f.Name), pt.Name, obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported pointer type %v", pt)
			}
		}
	case *gocode.Map:
		{
			switch vt := t.ValueType.(type) {
			case *gocode.UserType:
				{
					return fmt.Sprintf(`
    msg.%s = make(map[%s]*%s.%s)
	for k, v := range %s%s {
		msg.%s[k] = marshall_%s_%s(new(%s.%s), &v)
	}`, strings.Title(f.Name), t.KeyType, pkg, vt.Name, obj, f.Name, strings.Title(f.Name), pkg, vt.Name, pkg, vt.Name), nil
				}
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented map value type %v", vt)
			}
		}
	case *gocode.Slice:
		{
			switch st := t.SliceOf.(type) {
			case *gocode.UserType:
				return fmt.Sprintf(
					"for _, v := range %s%s { msg.%s = append(msg.%s, marshall_%s_%s(new(%s.%s), &v)) }",
					obj, f.Name, strings.Title(f.Name), strings.Title(f.Name), pkg, st.Name, pkg, st.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented slice type %v", st)
			}
		}
	}
	return "", nil
}

func (f *ThriftField) Unmarshall(imports *gogen.Imports, obj string, pkg string) (string, error) {
	switch t := f.ThriftGoType.(type) {
	case *gocode.UserType:
		{
			return fmt.Sprintf("unmarshall_%s_%s(msg.%s,&%s%s)", pkg, t.Name, strings.Title(f.Name), obj, f.Name), nil
		}
	case *gocode.BasicType:
		{
			return fmt.Sprintf("%s%s = %v(msg.%s)", obj, f.Name, f.SrcType, strings.Title(f.Name)), nil
		}
	case *gocode.Pointer:
		{
			switch pt := t.PointerTo.(type) {
			case *gocode.UserType:
				return fmt.Sprintf("unmarshall_%s_%s(msg.%s, %s%s)", pkg, pt.Name, strings.Title(f.Name), obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("%s%s = &%v(msg.%s)", obj, f.Name, f.SrcType, strings.Title(f.Name)), nil
			default:
				return "", blueprint.Errorf("unsupported pointer type %v", pt)
			}
		}
	case *gocode.Map:
		{
			switch vt := t.ValueType.(type) {
			case *gocode.UserType:
				{
					return fmt.Sprintf(`
    %s%s = make(%s)
	for k, v := range msg.%s {
		objv := %s%s[k]
		unmarshall_%s_%s(v, &objv)
	}`, obj, f.Name, imports.NameOf(f.SrcType), strings.Title(f.Name), obj, f.Name, pkg, vt.Name), nil
				}
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported map value type %v", t)
			}
		}
	case *gocode.Slice:
		{
			switch st := t.SliceOf.(type) {
			case *gocode.UserType:
				return fmt.Sprintf(`
	%s%s = make(%s, len(msg.%s))
	for i, v := range msg.%s {
		unmarshall_%s_%s(v, &%s%s[i])
	}`, obj, f.Name, imports.NameOf(f.SrcType), strings.Title(f.Name), strings.Title(f.Name), pkg, st.Name, obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("%s%s = msg.%s", obj, f.Name, strings.Title(f.Name)), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented slice type %v", st)
			}
		}
	}
	return "", nil
}
