// Package OpenTelemetry provides a Blueprint plugin for instrumenting services and collecting OpenTelemetry traces. The plugin provides APIs to be used in the wiring specification for the following:
//
//  1. to wrap the service with an OpenTelemetry wrapper to generate OT compatible traces by starting and stopping client spans for remote calls between services and correctly propagating context between services. The traces are then exported to a collector client such as [jaeger] or [zipkin].
//  2. to install an opentelemetry trace-based event logger for a go process. The logger adds all the logs as events to the current active span. If no active span exists, then no events are logged.
//
// Once the application is instrumented with these plugins, traces will be generated by the instrumented services, and collected centrally at the trace collector.
//
// # Wiring Usage
//
// To instrument services with opentelemetry instrumentation:
//
//	opentelemetry.Instrument(spec, "my_service", "collector_name")
//
// Calling [Instrument] will generate client and server side wrappers responsible for starting and stopping spans as well as correctly propagating the context across service boundaries.
//
// To redirect a process's logging statements to opentelemetry generated spans:
//
//	opentelemetry.Logger(spec, "my_process")
//
// Calling [Logger] will redirect all logging statements generated by the process to opentelemetry where the log statements will be converted into opentelemetry Events and added to the list of events for the current active span.
//
// In order to generate complete end-to-end traces of the application, all services of the application need to be instrumented with OpenTelemetry.
// If the plugin is only applied to a subset of services, the application will run, but the traces produced won't be end-to-end and won't be useful.
// The plugin does not support instrumenting clients for backends such as databases, caches, queues, etc. If needed, please consider submitting a PR or contacting the maintainers via google groups or on slack.
//
// # Artifacts Generated
//
//  1. The package generates client and server side wrappers for instrumented services that contain opentelemetry instrumentation (context propagation, creation of spans). The generated clients handle context propagation correctly on both the server and client sides. The implementation of the logger is located at [runtime/plugins/opentelemetry] and if the opentelemetry logger is installed for a process then this logger is used.
//
// Example usage (for complete instrumentation):
//
// # Wiring Example
//
//	func applyOTelOptions() {
//		jaeger.Container(spec, "jaeger")
//		for _, service := range serviceNames {
//			opentelemetry.Instrument(spec, service)
//		}
//		for _, proc := range processNames {
//			opentelemetry.Logger(spec, proc)
//		}
//	}
//
// See the [ot_logger] wiring spec for the Leaf application for a complete example
//
// # Accessing Traces
//
// The traces are generated and sent to the configured ([zipkin] or [jaeger]) collector. Each collector exposes a web UI which can be used to access end-to-end traces. For Zipkin, the UI is hosted at port 9411 by default and for Jaeger, the UI is hosted at port 16686 by default.
//
// [ot_logger]: https://github.com/Blueprint-uServices/blueprint/tree/main/examples/leaf/wiring/specs/custom_logger.go
// [zipkin]: https://github.com/Blueprint-uServices/blueprint/tree/main/plugins/zipkin
// [jaeger]: https://github.com/Blueprint-uServices/blueprint/tree/main/plugins/jaeger
package opentelemetry

import (
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/coreplugins/pointer"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/ir"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/wiring"
	"github.com/blueprint-uservices/blueprint/plugins/golang"
	"github.com/blueprint-uservices/blueprint/plugins/goproc"
	"golang.org/x/exp/slog"
)

func instrument(spec wiring.WiringSpec, serviceName string, collectorName string, genClientSpan bool) {
	// The nodes that we are defining
	clientWrapper := serviceName + ".client.ot"
	serverWrapper := serviceName + ".server.ot"

	// Get the pointer metadata
	ptr := pointer.GetPointer(spec, serviceName)
	if ptr == nil {
		slog.Error("Unable to instrument " + serviceName + " with OpenTelemetry as it is not a pointer")
		return
	}

	// Add the client wrapper to the pointer src
	clientNext := ptr.AddClientModifier(spec, clientWrapper)

	// Define the client wrapper
	spec.Define(clientWrapper, &OpenTelemetryClientWrapper{}, func(namespace wiring.Namespace) (ir.IRNode, error) {
		var server golang.Service
		err := namespace.Get(clientNext, &server)
		if err != nil {
			return nil, err
		}

		var collectorClient OpenTelemetryCollectorInterface
		err = namespace.Get(collectorName, &collectorClient)
		if err != nil {
			return nil, err
		}

		return newOpenTelemetryClientWrapper(clientWrapper, server, collectorClient, genClientSpan)
	})

	// Add the server wrapper to the pointer dst
	serverNext := ptr.AddServerModifier(spec, serverWrapper)

	// Define the server wrapper
	spec.Define(serverWrapper, &OpenTelemetryServerWrapper{}, func(namespace wiring.Namespace) (ir.IRNode, error) {
		var wrapped golang.Service
		err := namespace.Get(serverNext, &wrapped)
		if err != nil {
			return nil, err
		}

		var collectorClient OpenTelemetryCollectorInterface
		err = namespace.Get(collectorName, &collectorClient)
		if err != nil {
			return nil, err
		}

		return newOpenTelemetryServerWrapper(serverWrapper, wrapped, collectorClient)
	})

}

// [Instrument] can be used by wiring specs to instrument `serviceName` with OpenTelemetry.  This can only be done if `serviceName` is a service declared in the wiring spec using [workflow.Define] and has not yet been deployed over the network using grpc, thrift, or http.
//
// This call will configure the generated clients on server and client side to use the exporter provided by the custom collector indicated by the `collectorName`.
// The `collectorName` must already be declared in the wiring spec.
func Instrument(spec wiring.WiringSpec, serviceName string, collectorName string) {
	instrument(spec, serviceName, collectorName, true)
}

func InstrumentWithoutClientSpans(spec wiring.WiringSpec, serviceName string, collectorName string) {
	instrument(spec, serviceName, collectorName, false)
}

// [Logger] can be used by wiring specs to install a process-level ot logger for process `processName` to be used in tandem with an OT Tracer. Replaces the existing logger installed for the process.
//
// Logs are added as `ot.Events` to the current span and will be added as events to the current span and won't appear in stdout.
//
// If no current span is being recorded, then no events will be generated. Use `Instrument` to ensure that all services in a process are instrumented with OpenTelemetry and are creating active spans.
//
// # Wiring Spec Usage:
//
//	opentelemetry.Logger(spec, "my_process")
func Logger(spec wiring.WiringSpec, processName string) string {
	logger := processName + "_ottrace_logger"
	spec.Define(logger, &OTTraceLogger{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		return newOTTraceLogger(logger)
	})
	goproc.SetLogger(spec, processName, logger)
	return logger
}
