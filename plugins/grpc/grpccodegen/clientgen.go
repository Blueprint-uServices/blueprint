package grpccodegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
)

type clientWrapperArgs struct {
	Builder  golang.ModuleBuilder
	Package  string
	FilePath string
	Service  *gocode.ServiceInterface
	Name     string            // Name of the generated wrapper class
	Imports  map[string]string // map from import shortname to fully qualified package name
}

/*
It is assumed that outputPackage is the same as the one where the .proto is generated to
*/
func GenerateClientWrapper(builder golang.ModuleBuilder, service *gocode.ServiceInterface, outputPackage string) error {
	client := &clientWrapperArgs{}
	client.Builder = builder
	splits := strings.Split(outputPackage, "/")
	outputPackageName := splits[len(splits)-1]
	client.Package = outputPackageName
	client.Service = service
	client.Name = service.Name + "_GRPCClientWrapper"

	outputDir := filepath.Join(builder.Path(), filepath.Join(splits...))
	err := os.MkdirAll(outputDir, 0755)
	if err != nil {
		return fmt.Errorf("unable to create grpc output dir %v due to %v", outputDir, err.Error())
	}

	client.Imports = make(map[string]string)

	builder.Require("google.golang.org/grpc", "v1.41.0")

	outputFilename := service.Name + "_GRPCClientWrapper.go"
	return client.GenerateCode(filepath.Join(outputDir, outputFilename))
}

func (client *clientWrapperArgs) importPackage(pkg string) string {
	splits := strings.Split(pkg, "/")
	pkgShortName := splits[len(splits)-1]
	importAs := pkgShortName
	i := 2
	for {
		if existingPkg, exists := client.Imports[importAs]; exists {
			if existingPkg == pkg {
				return importAs
			} else {
				importAs = fmt.Sprintf("%v%v", pkgShortName, i)
				i += 1
			}
		} else {
			client.Imports[importAs] = pkg
			return importAs
		}
	}
}

var clientWrapperTemplate = `// Blueprint: Auto-generated by GRPC Plugin
package {{.Package}}

import (
	"context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"errors"
	"time"
	{{ range $importAs, $package := .Imports }}{{ $importAs }} "{{ $package }}"
	{{ end }}
)

type {{.Name}} struct {
	Client {{.Service.Name}}Client // The GRPC-generated client
	Timeout time.Duration
}

func New_{{.Name}}(serverAddress string) (*{{.Name}}, error) {
	var opts []grpc.DialOption
	opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))
	duration, err := time.ParseDuration("1s")
	if err != nil {
		return nil, err
	}
	opts = append(opts, grpc.WithTimeout(duration))
	conn, err := grpc.Dial(serverAddress, opts...)
	if err != nil {
		return nil, err
	}

	wrapper := &{{.Name}}{}
	wrapper.Client = New{{.Service.Name}}Client(conn)
	wrapper.Timeout = duration
	return wrapper, nil
}

// TODO: WIP
`

/*
Generates the file within its module
*/
func (client *clientWrapperArgs) GenerateCode(outputFilePath string) error {
	t, err := template.New("grpc_client_wrapper").Parse(clientWrapperTemplate)
	if err != nil {
		return err
	}

	f, err := os.OpenFile(outputFilePath, os.O_CREATE, 0755)
	if err != nil {
		return err
	}

	return t.Execute(f, client)
}
