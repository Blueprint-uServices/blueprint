package grpccodegen

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/blueprint-uservices/blueprint/blueprint/pkg/blueprint"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gocode"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gogen"
)

var marshallFileTemplate = `// Blueprint: Auto-generated by GRPC Plugin marshallgen.go
package {{.Package}}

{{.Imports}}

{{$imports := .Imports -}}
{{ range $_1, $service := .Services -}}
{{ range $_2, $method := $service.Methods -}}
// Client-side function to pack {{$service.Name}}.{{$method.Name}} args into a GRPC {{$method.Request.GRPCType.Name}} struct
func (msg *{{$method.Request.GRPCType.Name}}) marshall(
	{{- range $j, $arg := $method.Request.FieldList}}{{if $j}}, {{end}}{{$arg.Name}} {{$imports.NameOf $arg.SrcType}}{{end -}}
) *{{$method.Request.GRPCType.Name}} {
	{{- range $j, $arg := $method.Request.FieldList}}
	{{$arg.Marshall $imports ""}}
	{{- end}}
	return msg
}

// Server-side function to unpack {{$service.Name}}.{{$method.Name}} args from a GRPC {{$method.Request.GRPCType.Name}} struct
func (msg *{{$method.Request.GRPCType.Name}}) unmarshall() (
	{{- range $j, $arg := $method.Request.FieldList}}{{if $j}}, {{end}}{{$arg.Name}} {{$imports.NameOf $arg.SrcType}}{{end -}}
) {
	{{- range $j, $arg := $method.Request.FieldList}}
	{{$arg.Unmarshall $imports ""}}
	{{- end}}
	return
}

// Server-side function to pack {{$service.Name}}.{{$method.Name}} retvals into a GRPC {{$method.Response.GRPCType.Name}} struct
func (msg *{{$method.Response.GRPCType.Name}}) marshall(
	{{- range $j, $ret := $method.Response.FieldList}}{{if $j}}, {{end}}{{$ret.Name}} {{$imports.NameOf $ret.SrcType}}{{end -}}
) *{{$method.Response.GRPCType.Name}} {
	{{- range $j, $ret := $method.Response.FieldList}}
	{{$ret.Marshall $imports ""}}
	{{- end}}
	return msg
}

// Client-side function to unpack {{$service.Name}}.{{$method.Name}} retvals from a GRPC {{$method.Response.GRPCType.Name}} struct
func (msg *{{$method.Response.GRPCType.Name}}) unmarshall() (
	{{- range $j, $ret := $method.Response.FieldList}}{{if $j}}, {{end}}{{$ret.Name}} {{$imports.NameOf $ret.SrcType}}{{end -}}
) {
	{{- range $j, $ret := $method.Response.FieldList}}
	{{$ret.Unmarshall $imports ""}}
	{{- end}}
	return
}

{{end -}}
{{end -}}

{{ range $t, $struct := .Structs}}
// Utility function to pack {{$imports.Qualify $t.Package $t.Name}} into a GRPC {{$struct.GRPCType.Name}} message
func (msg *{{$struct.GRPCType.Name}}) marshall(obj *{{$imports.Qualify $t.Package $t.Name}}) *{{$struct.GRPCType.Name}} {
	{{- range $j, $field := $struct.FieldList}}
	{{$field.Marshall $imports "obj."}}
	{{- end}}
	return msg
}

// Utility function to unpack {{$imports.Qualify $t.Package $t.Name}} from a GRPC {{$struct.GRPCType.Name}} message
func (msg *{{$struct.GRPCType.Name}}) unmarshall(obj *{{$imports.Qualify $t.Package $t.Name}}) {
	{{- range $j, $field := $struct.FieldList}}
	{{$field.Unmarshall $imports "obj."}}
	{{- end}}
}
{{end}}
`

type marshallArgs struct {
	gRPCProtoBuilder
	Imports *gogen.Imports
}

/*
Generates marshalling functions that convert between Go objects and GRPC message objects

This extends the code in protogen.go and is called from protogen.go
*/

func (b *gRPCProtoBuilder) GenerateMarshallingCode(outputFilePath string) error {
	t, err := template.New("marshallGRPC").Parse(marshallFileTemplate)
	if err != nil {
		return err
	}

	f, err := os.OpenFile(outputFilePath, os.O_CREATE|os.O_RDWR, 0755)
	if err != nil {
		return err
	}

	args := &marshallArgs{}
	args.gRPCProtoBuilder = *b
	args.Imports = gogen.NewImports(args.PackageName)

	for _, msg := range args.gRPCProtoBuilder.Messages {
		for _, field := range msg.FieldList {
			args.Imports.AddType(field.SrcType)
		}
	}

	return t.Execute(f, args)
}

func (f *gRPCField) Marshall(imports *gogen.Imports, obj string) (string, error) {
	switch t := f.GRPCType.(type) {
	case *gocode.UserType:
		{
			return fmt.Sprintf("msg.%s = new(%s).marshall(&%s%s)", strings.Title(f.Name), t.Name, obj, f.Name), nil
		}
	case *gocode.BasicType:
		{
			return fmt.Sprintf("msg.%s = %s(%s%s)", strings.Title(f.Name), t.Name, obj, f.Name), nil
		}
	case *gocode.Pointer:
		{
			switch pt := t.PointerTo.(type) {
			case *gocode.UserType:
				return fmt.Sprintf("msg.%s = new(%s).marshall(%s%s)", strings.Title(f.Name), pt.Name, obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s(*%s%s)", strings.Title(f.Name), pt.Name, obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported pointer type %v", pt)
			}
		}
	case *gocode.Map:
		{
			switch vt := t.ValueType.(type) {
			case *gocode.UserType:
				{
					return fmt.Sprintf(`
    msg.%s = make(map[%s]*%s)
	for k, v := range %s%s {
		msg.%s[k] = new(%s).marshall(&v)
	}`, strings.Title(f.Name), t.KeyType, vt.Name, obj, f.Name, strings.Title(f.Name), vt.Name), nil
				}
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented map value type %v", vt)
			}
		}
	case *gocode.Slice:
		{
			switch st := t.SliceOf.(type) {
			case *gocode.UserType:
				return fmt.Sprintf(
					"for _, v := range %s%s { msg.%s = append(msg.%s, new(%s).marshall(&v)) }",
					obj, f.Name, strings.Title(f.Name), strings.Title(f.Name), st.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented slice type %v", st)
			}
		}
	}
	return "", nil
}

func (f *gRPCField) Unmarshall(imports *gogen.Imports, obj string) (string, error) {
	switch t := f.GRPCType.(type) {
	case *gocode.UserType:
		{
			return fmt.Sprintf("msg.%s.unmarshall(&%s%s)", strings.Title(f.Name), obj, f.Name), nil
		}
	case *gocode.BasicType:
		{
			return fmt.Sprintf("%s%s = %v(msg.%s)", obj, f.Name, f.SrcType, strings.Title(f.Name)), nil
		}
	case *gocode.Pointer:
		{
			switch pt := t.PointerTo.(type) {
			case *gocode.UserType:
				return fmt.Sprintf("msg.%s.unmarshall(%s%s)", strings.Title(f.Name), obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("%s%s = &%v(msg.%s)", obj, f.Name, f.SrcType, strings.Title(f.Name)), nil
			default:
				return "", blueprint.Errorf("unsupported pointer type %v", pt)
			}
		}
	case *gocode.Map:
		{
			switch t.ValueType.(type) {
			case *gocode.UserType:
				{
					return fmt.Sprintf(`
    %s%s = make(%s)
	for k, v := range msg.%s {
		objv := %s%s[k]
		v.unmarshall(&objv)
	}`, obj, f.Name, imports.NameOf(f.SrcType), strings.Title(f.Name), obj, f.Name), nil
				}
			case *gocode.BasicType:
				return fmt.Sprintf("msg.%s = %s%s", strings.Title(f.Name), obj, f.Name), nil
			default:
				return "", blueprint.Errorf("unsupported map value type %v", t)
			}
		}
	case *gocode.Slice:
		{
			switch st := t.SliceOf.(type) {
			case *gocode.UserType:
				return fmt.Sprintf(`
	%s%s = make(%s, len(msg.%s))
	for i, v := range msg.%s {
		v.unmarshall(&%s%s[i])
	}`, obj, f.Name, imports.NameOf(f.SrcType), strings.Title(f.Name), strings.Title(f.Name), obj, f.Name), nil
			case *gocode.BasicType:
				return fmt.Sprintf("%s%s = msg.%s", obj, f.Name, strings.Title(f.Name)), nil
			default:
				return "", blueprint.Errorf("unsupported/unimplemented slice type %v", st)
			}
		}
	}
	return "", nil
}
