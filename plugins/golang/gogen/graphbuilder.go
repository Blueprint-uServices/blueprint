package gogen

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/blueprint"
	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/core/irutil"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
)

/*
Implements the GraphBuilder interface defined in gogen/ir.go

GraphBuilder is useful for any golang namespace node, such as the goproc plugin, that wants to be able
to instantiate Golang IR nodes.

The GraphBuilder accumulates code from child nodes and stubs for instantiating the code.

The GraphBuilder can then be used to generate a source file that constructs the graph.

The typical usage of a `GraphBuilder` is to:

 1. Create a new `GraphBuilder` with the `NewGraphBuilder` method

 2. Collect code definitions from child nodes by calling `Instantiable.AddInstantiation` on those nodes

 3. Generate the final output by calling `GraphBuilder.Finish`
*/
type GraphBuilderImpl struct {
	golang.GraphBuilder
	tracker      irutil.VisitTrackerImpl
	FileName     string             // The short name of the file
	FilePath     string             // The fully qualified path to the file
	module       *ModuleBuilderImpl // The module containing this file
	PackagePath  string             // The package path within the module
	Package      string             // The package name in the package declaration within the file
	FuncName     string             // The name of the function to generaet
	Imports      *Imports           // Import declarations in the file; map of shortname to full package import name
	Declarations map[string]string  // The DI declarations
}

/*
Create a new GraphBuilder
*/
func NewGraphBuilder(module *ModuleBuilderImpl, fileName, packagePath, funcName string) (*GraphBuilderImpl, error) {
	err := CheckDir(module.ModuleDir, false)
	if err != nil {
		return nil, fmt.Errorf("unable to generate %s for module %s due to %s", fileName, module.ShortName, err.Error())
	}

	packageDir := filepath.Join(module.ModuleDir, packagePath)
	err = CheckDir(packageDir, true)
	if err != nil {
		return nil, fmt.Errorf("unable to generate %s for module %s due to %s", fileName, module.ShortName, err.Error())
	}

	builder := &GraphBuilderImpl{}
	builder.FileName = fileName
	builder.FilePath = filepath.Join(packageDir, fileName)
	builder.module = module
	builder.PackagePath = packagePath
	splits := strings.Split(packagePath, "/")
	builder.Package = splits[len(splits)-1]
	builder.Imports = NewImports(packagePath)
	builder.Declarations = make(map[string]string)
	builder.FuncName = funcName

	// Add the runtime module as a dependency, in case it hasn't already
	builder.module.workspace.AddLocalModuleRelative("runtime", "../../../runtime")
	builder.module.Require("gitlab.mpi-sws.org/cld/blueprint/runtime", "v0.0.0")
	builder.Imports.AddPackage("gitlab.mpi-sws.org/cld/blueprint/runtime/plugins/golang")
	builder.Imports.AddPackage("context")

	return builder, nil
}

func (graph *GraphBuilderImpl) Info() golang.GraphInfo {
	return golang.GraphInfo{
		PackageName: graph.module.Name + "/" + graph.PackagePath,
		FilePath:    graph.FilePath,
	}
}

func (graph *GraphBuilderImpl) Visit(nodes []blueprint.IRNode) error {
	for _, node := range nodes {
		if n, valid := node.(golang.Instantiable); valid {
			err := n.AddInstantiation(graph)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (code *GraphBuilderImpl) Module() golang.ModuleBuilder {
	return code.module
}

func (code *GraphBuilderImpl) Import(packageName string) string {
	return code.Imports.AddPackage(packageName)
}

func (code *GraphBuilderImpl) ImportType(typeName gocode.TypeName) string {
	code.Module().RequireType(typeName)
	code.Imports.AddType(typeName)
	return code.Imports.NameOf(typeName)
}

func (graph *GraphBuilderImpl) Declare(name, buildFuncSrc string) error {
	if _, exists := graph.Declarations[name]; exists {
		return fmt.Errorf("generated file %s encountered redeclaration of %s", graph.FileName, name)
	}
	graph.Declarations[name] = buildFuncSrc
	return nil
}

type buildFuncConstructorArg struct {
	Graph    *GraphBuilderImpl
	Var      gocode.Variable
	Node     blueprint.IRNode
	NodeName string
	NodeType gocode.TypeName
}

type buildFuncArgs struct {
	Graph        *GraphBuilderImpl
	Name         string
	InstanceName string
	Constructor  *gocode.UserType
	Args         []buildFuncConstructorArg
}

var buildFuncTemplate = `func(ctr golang.Container) (any, error) {
		// Auto-generated by the golang plugin gogen/graphbuilder.go
		{{- range $i, $arg := .Args }}
		{{.NodeName}}, err := ctr.Get("{{.Node.Name}}")
		if err != nil {
			return nil, err
		}

		// {{.Var.Name}} is expected to be a {{.Var.Type}}
		{{.Var.Name}}, is{{.Var.Name}}Valid := {{.NodeName}}.({{.Graph.ImportType .NodeType}})
		if !is{{.Var.Name}}Valid {
			return nil, fmt.Errorf("blueprint gogen/graphbuilder.go expected {{.Node.Name}} to implement {{.NodeType}}")
		}
		{{end}}
		return {{.Graph.ImportType .Constructor}}({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.Var.Name}}{{end}})
	}`

func (graph *GraphBuilderImpl) DeclareConstructor(name string, constructor *gocode.Constructor, args []blueprint.IRNode) error {
	if len(constructor.Arguments) != len(args) {
		argNames := []string{}
		for _, arg := range args {
			argNames = append(argNames, arg.Name())
		}
		return fmt.Errorf("mismatched args for %v.  Expected: %v.  Got: (%v)", name, constructor, strings.Join(argNames, ", "))
	}

	graph.Import("fmt")

	templateName := fmt.Sprintf("di.Declare(%v)", name)
	templateArgs := buildFuncArgs{
		Graph:        graph,
		Name:         name,
		InstanceName: irutil.Clean(name),
		Constructor:  &gocode.UserType{Source: constructor.Source, Name: constructor.Name},
	}
	for i, Var := range constructor.Arguments {
		arg := buildFuncConstructorArg{
			Graph:    graph,
			Var:      Var,
			Node:     args[i],
			NodeName: irutil.Clean(args[i].Name()),
			NodeType: &gocode.BasicType{Name: "string"},
		}

		if service, argNodeIsAService := args[i].(golang.Service); argNodeIsAService {
			iface, hasGoInterface := service.GetInterface().(*gocode.ServiceInterface)
			if !hasGoInterface {
				return fmt.Errorf("argument %v %v to constructor %v of %v should be a gocode.ServiceInterface, but got %v", i, args[i].Name(), constructor.Name, name, service.GetInterface())
			}
			arg.NodeType = &iface.UserType
		}

		templateArgs.Args = append(templateArgs.Args, arg)
	}

	t, err := template.New(templateName).Parse(buildFuncTemplate)
	if err != nil {
		return err
	}

	// Generate the code
	buf := &bytes.Buffer{}
	err = t.Execute(buf, templateArgs)
	if err != nil {
		return err
	}

	return graph.Declare(name, buf.String())
}

func (code *GraphBuilderImpl) Visited(name string) bool {
	return code.tracker.Visited(name)
}

var diFuncTemplate = `package {{.Package}}

{{.Imports}}

func {{ .FuncName }}(ctx context.Context, cancel context.CancelFunc, args map[string]string) (golang.Container, error) {
	g := golang.NewGraph(ctx, cancel)

	var err error
	for k := range args {
		v := args[k]
		err = g.Define(k, func(ctr golang.Container) (any, error) { return v, nil })
		if err != nil {
			return nil, err
		}
	}

	{{ range $defName, $buildFunc := .Declarations }}
	err = g.Define("{{ $defName }}", {{ $buildFunc }})
	if err != nil {
		return nil, err
	}
	{{ end }}

	return g.Build(), nil
}
`

/*
Generates the file within its module
*/
func (code *GraphBuilderImpl) Build() error {
	t, err := template.New(code.FuncName).Parse(diFuncTemplate)
	if err != nil {
		return err
	}

	f, err := os.OpenFile(code.FilePath, os.O_CREATE|os.O_RDWR, 0755)
	if err != nil {
		return err
	}

	return t.Execute(f, code)
}
