package gogen

import (
	"path/filepath"
	"strings"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/blueprint"
	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/core/irutil"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
)

/*
Implements the GraphBuilder interface defined in gogen/ir.go

GraphBuilder is useful for any golang namespace node, such as the goproc plugin, that wants to be able
to instantiate Golang IR nodes.

The GraphBuilder accumulates code from child nodes and stubs for instantiating the code.

The GraphBuilder can then be used to generate a source file that constructs the graph.

The typical usage of a `GraphBuilder` is to:

 1. Create a new `GraphBuilder` with the `NewGraphBuilder` method

 2. Collect code definitions from child nodes by calling `Instantiable.AddInstantiation` on those nodes

 3. Generate the final output by calling `GraphBuilder.Finish`
*/
type GraphBuilderImpl struct {
	golang.GraphBuilder
	tracker      irutil.VisitTrackerImpl
	module       *ModuleBuilderImpl // The module containing this file
	Package      golang.PackageInfo
	FileName     string            // The short name of the file
	FilePath     string            // The fully qualified path to the file
	FuncName     string            // The name of the function to generate
	Imports      *Imports          // Import declarations in the file; map of shortname to full package import name
	Declarations map[string]string // The DI declarations
}

/*
Create a new GraphBuilder
*/
func NewGraphBuilder(module *ModuleBuilderImpl, fileName, packagePath, funcName string) (*GraphBuilderImpl, error) {
	pkg, err := module.CreatePackage(packagePath)
	if err != nil {
		return nil, err
	}

	graph := &GraphBuilderImpl{
		module:       module,
		Package:      pkg,
		FileName:     fileName,
		FilePath:     filepath.Join(pkg.Path, fileName),
		FuncName:     funcName,
		Imports:      NewImports(pkg.Path),
		Declarations: make(map[string]string),
	}

	// Add the runtime module as a dependency, in case it hasn't already
	err = graph.module.workspace.AddLocalModuleRelative("runtime", "../../../runtime")
	if err != nil {
		return nil, err
	}

	graph.Imports.AddPackages(
		"context", "fmt",
		"gitlab.mpi-sws.org/cld/blueprint/runtime/plugins/golang",
	)

	return graph, nil
}

func (graph *GraphBuilderImpl) Visit(nodes []blueprint.IRNode) error {
	for _, node := range nodes {
		if n, valid := node.(golang.Instantiable); valid {
			err := n.AddInstantiation(graph)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (code *GraphBuilderImpl) Module() golang.ModuleBuilder {
	return code.module
}

func (graph *GraphBuilderImpl) Declare(name, buildFuncSrc string) error {
	if _, exists := graph.Declarations[name]; exists {
		return blueprint.Errorf("generated file %s encountered redeclaration of %s", graph.FileName, name)
	}
	graph.Declarations[name] = buildFuncSrc
	return nil
}

type buildFuncConstructorArg struct {
	Graph    *GraphBuilderImpl
	Var      gocode.Variable
	Node     blueprint.IRNode
	NodeName string
	NodeType gocode.TypeName
}

type buildFuncArgs struct {
	Graph        *GraphBuilderImpl
	Name         string
	InstanceName string
	Constructor  *gocode.UserType
	Args         []buildFuncConstructorArg
}

var buildFuncTemplate = `func(ctr golang.Container) (any, error) {
		// Auto-generated by the golang plugin gogen/graphbuilder.go
		{{- range $i, $arg := .Args }}
		{{.NodeName}}, err := ctr.Get("{{.Node.Name}}")
		if err != nil {
			return nil, err
		}

		// {{.Var.Name}} is expected to be a {{.Var.Type}}
		{{.Var.Name}}, is{{.Var.Name}}Valid := {{.NodeName}}.({{.Graph.Imports.NameOf .NodeType}})
		if !is{{.Var.Name}}Valid {
			return nil, fmt.Errorf("blueprint gogen/graphbuilder.go expected {{.Node.Name}} to implement {{.NodeType}}")
		}
		{{end}}
		return {{.Graph.Imports.NameOf .Constructor}}({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.Var.Name}}{{end}})
	}`

func (graph *GraphBuilderImpl) DeclareConstructor(name string, constructor *gocode.Constructor, args []blueprint.IRNode) error {
	if len(constructor.Arguments) != len(args) {
		argNames := []string{}
		for _, arg := range args {
			argNames = append(argNames, arg.Name())
		}
		return blueprint.Errorf("mismatched args for %v.  Expected: %v.  Got: (%v)", name, constructor, strings.Join(argNames, ", "))
	}

	templateArgs := buildFuncArgs{
		Graph:        graph,
		Name:         name,
		InstanceName: irutil.Clean(name),
		Constructor:  &gocode.UserType{Package: constructor.Package, Name: constructor.Name},
	}
	for i, Var := range constructor.Arguments {
		arg := buildFuncConstructorArg{
			Graph:    graph,
			Var:      Var,
			Node:     args[i],
			NodeName: irutil.Clean(args[i].Name()),
			NodeType: &gocode.BasicType{Name: "string"},
		}

		if service, argNodeIsAService := args[i].(golang.Service); argNodeIsAService {
			arg.NodeType = &service.GetGoInterface().UserType
		}

		templateArgs.Args = append(templateArgs.Args, arg)
	}

	code, err := ExecuteTemplate("declare"+name, buildFuncTemplate, templateArgs)
	if err != nil {
		return err
	}

	return graph.Declare(name, code)
}

func (code *GraphBuilderImpl) Visited(name string) bool {
	return code.tracker.Visited(name)
}

var diFuncTemplate = `package {{.Package.ShortName}}

{{.Imports}}

func {{ .FuncName }}(ctx context.Context, cancel context.CancelFunc, args map[string]string) (golang.Container, error) {
	g := golang.NewGraph(ctx, cancel)

	var err error
	for k := range args {
		v := args[k]
		err = g.Define(k, func(ctr golang.Container) (any, error) { return v, nil })
		if err != nil {
			return nil, err
		}
	}

	{{ range $defName, $buildFunc := .Declarations }}
	err = g.Define("{{ $defName }}", {{ $buildFunc }})
	if err != nil {
		return nil, err
	}
	{{ end }}

	return g.Build(), nil
}
`

/*
Generates the file within its module
*/
func (code *GraphBuilderImpl) Build() error {
	return ExecuteTemplateToFile("graph_"+code.FuncName, diFuncTemplate, code, code.FilePath)
}
