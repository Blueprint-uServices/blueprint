package gogen

import (
	"fmt"
	"path/filepath"
	"strings"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/blueprint"
	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/ir"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
	"golang.org/x/exp/slog"
)

/*
Implements the [ir.NamespaceBuilder] interface defined in gogen/ir.go

[ir.NamespaceBuilder] is useful for any golang namespace node, such as the goproc plugin, that wants to be able
to instantiate Golang IR nodes.

The [ir.NamespaceBuilder] accumulates code from child nodes and stubs for instantiating the code.

The [ir.NamespaceBuilder] can then be used to generate a source file that constructs the namespace.

The typical usage of a [ir.NamespaceBuilder] is to:

 1. Create a new [ir.NamespaceBuilder] with the [NewNamespaceBuilder] method

 2. Collect code definitions from child nodes by calling `Instantiable.AddInstantiation` on those nodes

 3. Generate the final output by calling `NamespaceBuilder.Finish`
*/
type NamespaceBuilderImpl struct {
	ir.VisitTrackerImpl
	module         golang.ModuleBuilder // The module containing this file
	Package        golang.PackageInfo
	Name           string            // IR node name
	FileName       string            // The short name of the file
	FilePath       string            // The fully qualified path to the file
	FuncName       string            // The name of the function to generate
	Imports        *Imports          // Import declarations in the file; map of shortname to full package import name
	Declarations   map[string]string // The DI declarations
	Required       map[string]string
	Optional       map[string]string
	Instantiations map[string]struct{}
}

/*
Create a new NamespaceBuilder
*/
func NewNamespaceBuilder(module golang.ModuleBuilder, name, fileName, packagePath, funcName string) (*NamespaceBuilderImpl, error) {
	pkg, err := module.CreatePackage(packagePath)
	if err != nil {
		return nil, err
	}

	n := &NamespaceBuilderImpl{
		module:         module,
		Name:           name,
		Package:        pkg,
		FileName:       fileName,
		FilePath:       filepath.Join(pkg.Path, fileName),
		FuncName:       funcName,
		Imports:        NewImports(pkg.Path),
		Declarations:   make(map[string]string),
		Required:       make(map[string]string),
		Optional:       make(map[string]string),
		Instantiations: make(map[string]struct{}),
	}

	// Add the runtime module as a dependency, in case it hasn't already
	err = golang.AddRuntimeModule(module.Workspace())
	if err != nil {
		return nil, err
	}

	n.Imports.AddPackages(
		"gitlab.mpi-sws.org/cld/blueprint/runtime/plugins/golang",
	)

	return n, nil
}

func (n *NamespaceBuilderImpl) Info() golang.NamespaceInfo {
	return golang.NamespaceInfo{
		Package:  n.Package,
		FileName: n.FileName,
		FilePath: n.FilePath,
		FuncName: n.FuncName,
	}
}

func (n *NamespaceBuilderImpl) Import(packageName string) string {
	return n.Imports.AddPackage(packageName)
}

func (n *NamespaceBuilderImpl) ImportType(typeName gocode.TypeName) string {
	return n.Imports.NameOf(typeName)
}

func (n *NamespaceBuilderImpl) Module() golang.ModuleBuilder {
	return n.module
}

func (n *NamespaceBuilderImpl) RequiredArg(name, description string) {
	n.Required[name] = description
}

func (n *NamespaceBuilderImpl) OptionalArg(name, description string) {
	n.Optional[name] = description
}

func (n *NamespaceBuilderImpl) Instantiate(name string) {
	n.Instantiations[name] = struct{}{}
}

func (n *NamespaceBuilderImpl) Declare(name, buildFuncSrc string) error {
	if _, exists := n.Declarations[name]; exists {
		return blueprint.Errorf("generated file %s encountered redeclaration of %s", n.FileName, name)
	}
	n.Declarations[name] = buildFuncSrc
	return nil
}

type buildFuncConstructorArg struct {
	Namespace *NamespaceBuilderImpl
	Var       gocode.Variable
	Node      ir.IRNode
	NodeName  string
	NodeType  gocode.TypeName
}

type buildFuncArgs struct {
	Namespace    *NamespaceBuilderImpl
	Name         string
	InstanceName string
	Constructor  *gocode.UserType
	Args         []buildFuncConstructorArg
}

var buildFuncTemplate = `func(n *golang.Namespace) (any, error) {
		// Auto-generated by the golang plugin gogen/namespacebuilder.go
		{{- range $i, $arg := .Args }}
		var {{.Var.Name}} {{.Namespace.Imports.NameOf .NodeType}}
		if err := n.Get("{{.Node.Name}}", &{{.Var.Name}}); err != nil {
			return nil, err
		}
		{{end}}
		return {{.Namespace.Imports.NameOf .Constructor}}(n.Context(), {{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.Var.Name}}{{end}})
	}`

func (namespace *NamespaceBuilderImpl) DeclareConstructor(name string, constructor *gocode.Constructor, args []ir.IRNode) error {
	if len(constructor.Arguments) != len(args)+1 {
		argNames := []string{}
		for _, arg := range args {
			argNames = append(argNames, arg.Name())
		}
		return blueprint.Errorf("mismatched args for %v.  Expected: %v.  Got: (ctx, %v)", name, constructor, strings.Join(argNames, ", "))
	}

	templateArgs := buildFuncArgs{
		Namespace:    namespace,
		Name:         name,
		InstanceName: ir.CleanName(name),
		Constructor:  &gocode.UserType{Package: constructor.Package, Name: constructor.Name},
	}
	for i, Var := range constructor.Arguments[1:] {
		if _, isMetadata := args[i].(ir.IRMetadata); isMetadata {
			return blueprint.Errorf("invalid constructor argument %v; metadata nodes are not instantiable", args[i].Name())
		}

		arg := buildFuncConstructorArg{
			Namespace: namespace,
			Var:       Var,
			Node:      args[i],
			NodeName:  ir.CleanName(args[i].Name()),
			NodeType:  &gocode.BasicType{Name: "string"},
		}

		if argIface, err := golang.GetGoInterface(namespace.Module(), args[i]); err == nil {
			arg.NodeType = &argIface.UserType
		}

		templateArgs.Args = append(templateArgs.Args, arg)
	}

	code, err := ExecuteTemplate("declare"+name, buildFuncTemplate, templateArgs)
	if err != nil {
		return err
	}

	return namespace.Declare(name, code)
}

var diFuncTemplate = `// Package {{.Package.ShortName}} is auto-generated by gogen/namespacebuilder.go
//
// It provides funcs for instantiating the {{.Name}} namespace.
//
// To instantiate the {{.Name}} namespace, first call [{{.FuncName}}] and then either call 
// [Build] or [BuildWithParent].
// 
// See [golang.NamespaceBuilder] docs for more information about the behavior of [Build]
package {{.Package.ShortName}}

{{.Imports}}

// Initializes the {{.Name}} namespace by defining all of the nodes that run
// within the namespace.
//
// [Build] or [BuildWithParent] must be called on the return value of this func
// to actually build and run the nodes in the namespace.
func {{ .FuncName }}(name string) *golang.NamespaceBuilder {
	b := golang.NewNamespaceBuilder(name)
	set_{{.Name}}_Args(b)
	set_{{.Name}}_Instances(b)
	set_{{.Name}}_Definitions(b)
	return b
}

// {{.Name}} requires that its arguments are either:
//  - explicitly set with [golang.NamespaceBuilder.Set]
//  - passed on the command line (if built using [golang.NamespaceBuilder.Build])
//  - are defined in parent (if built using [golang.NamespaceBuilder.BuildWithParent])
//
// The following arguments will be eagerly checked and building the namespace
// will fail if they haven't been provided:
{{- range $defName, $description := .Required }}
//   {{$defName}}
{{- end }}
//
// The following arguments are optional and a failure will only occur if the client
// tries to build a node that needs the argument to be set
{{- range $defName, $description := .Optional }}
//   {{$defName}}
{{- end }}
func set_{{.Name}}_Args(b *golang.NamespaceBuilder) {
	{{- range $defName, $description := .Required }}
	b.Required("{{$defName}}", "{{$description}}")
	{{- end }}
	{{- range $defName, $description := .Required }}
	b.Optional("{{$defName}}", "{{$description}}")
	{{- end }}
}

// When the {{.Name}} namespace is built it will automatically instantiate
// the following nodes:
{{- range $defName, $_ := .Instantiations }}
//   {{$defName}}
{{- end }}
func set_{{.Name}}_Instances(b *golang.NamespaceBuilder) {
	{{- range $defName, $_ := .Instantiations }}
	b.Instantiate("{{ $defName }}")
	{{- end }}
}

// The {{.Name}} namespace contains definitions for instantiating
// the following nodes:
{{- range $defName, $_ := .Declarations }}
//   {{$defName}}
{{- end }}
func set_{{.Name}}_Definitions(b *golang.NamespaceBuilder) {
	{{- range $defName, $buildFunc := .Declarations }}
	b.Define("{{ $defName }}", {{ $buildFunc }})
	{{ end }}
}
`

/*
Generates the file within its module
*/
func (code *NamespaceBuilderImpl) Build() error {
	slog.Info(fmt.Sprintf("Generating %v", filepath.Join(code.Package.PackageName, code.FileName)))
	return ExecuteTemplateToFile("namespace_"+code.FuncName, diFuncTemplate, code, code.FilePath)
}

func (code *NamespaceBuilderImpl) ImplementsBuildContext() {}
