package latency

import (
	"fmt"
	"path/filepath"

	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
	"golang.org/x/exp/slog"
)

// code generation function called from the ir.go file.
func generateServerWrapper(builder golang.ModuleBuilder, wrapped *gocode.ServiceInterface, outputPackage string) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	server := serverArgs{
		Package: pkg,
		Service: wrapped,
		Name:    wrapped.BaseName + "_LatencyInjector",
		Imports: gogen.NewImports(pkg.Name),
	}

	server.Imports.AddPackages("context", "time")
	slog.Info(fmt.Sprintf("Generating %v/%v", server.Package.PackageName, wrapped.BaseName+"_LatencyInjector"))
	outputFile := filepath.Join(server.Package.Path, wrapped.BaseName+"_LatencyInjector.go")

	return gogen.ExecuteTemplateToFile("LatencyInjector", serverTemplate, server, outputFile)
}

type serverArgs struct {
	Package golang.PackageInfo
	Service *gocode.ServiceInterface
	Name    string
	Imports *gogen.Imports
}

var serverTemplate = `// Blueprint: Auto-generated by LatencyInjector Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Server {{.Imports.NameOf .Service.UserType}}
	Latency time.Duration
}

func New_{{.Name}} (ctx context.Context, server {{.Imports.NameOf .Service.UserType}}, latency_str string) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Server = server
	latency, err := time.ParseDuration(latency_str)
	if err != nil {
		return nil, err
	}
	handler.Latency = latency
	return handler, nil
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{ range $_, $f := .Service.Methods }}
func (server *{{$receiver}}) {{$f.Name -}} ({{ArgVarsAndTypes $f "ctx context.Context"}}) ({{RetVarsAndTypes $f "err error"}}) {
	time.Sleep(server.Latency)
	return server.Server.{{$f.Name}}({{ArgVars $f "ctx"}})
}
{{end}}
`
