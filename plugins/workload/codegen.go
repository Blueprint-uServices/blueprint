package workload

import (
	"path/filepath"
	"strings"

	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
)

// Generates the workload generator client
func GenerateWorkloadgenCode(builder golang.ModuleBuilder, service *gocode.ServiceInterface, outputPackage string) error {
	wlgen := workloadTemplateArgs{}
	wlgen.Service = service
	wlgen.Name = service.Name + "_WorkloadGenerator"

	splits := strings.Split(outputPackage, "/")
	wlgen.PackageName = builder.Info().Name + "/" + outputPackage
	wlgen.PackageShortName = splits[len(splits)-1]

	wlgen.Imports = gogen.NewImports(wlgen.PackageName)
	wlgen.Imports.AddPackages("context", "fmt", "strings")

	outputDir := filepath.Join(builder.Info().Path, filepath.Join(splits...))
	outputFile := filepath.Join(outputDir, "workloadgen.go")
	return gogen.ExecuteTemplateToFile("workloadgen", workloadClientTemplate, wlgen, outputFile)
}

type workloadTemplateArgs struct {
	WorkloadgenClient
	Imports          *gogen.Imports
	Name             string
	Service          *gocode.ServiceInterface
	PackageName      string
	PackageShortName string
}

var workloadClientTemplate = `// Blueprint: Auto-generated by GRPC Plugin
package {{.PackageShortName}}

{{.Imports}}

type {{.Name}} struct {
	Service {{.Imports.NameOf .Service.UserType}}
}

func New_{{.Name}}(service {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	wlgen := &{{.Name}}{}
	wlgen.Service = service
	return wlgen, nil
}

// Blueprint: Run is called automatically in a separate goroutine by runtime/plugins/golang/di.go
func (wlgen *{{.Name}}) Run(ctx context.Context) error {
	{{ range $_, $f := .Service.Methods -}}
	err := wlgen.Call_{{$f.Name}}(ctx)
	if err != nil {
		return err
	}
	{{end}}

	return nil
}

// Utility method for printing values of args and retvals
func toString(values ...any) string {
	var s []string
	for _, v := range values {
		s = append(s, fmt.Sprintf("%v", v))
	}
	return strings.Join(s, ", ")
}


{{$service := .Service -}}
{{$receiver := .Name -}}
{{$imports := .Imports -}}
{{ range $_, $f := .Service.Methods }}
func (wlgen *{{$receiver}}) Call_{{$f.Name}}(ctx context.Context) error {
	{{range $i, $arg := $f.Arguments -}}
	var {{$arg.Name}} {{$imports.NameOf $arg.Type}}
	{{end}}
	fmt.Printf("{{$service.UserType.Name}}.{{$f.Name}}(%v)", toString({{range $i, $arg := $f.Arguments}}{{if $i}}, {{end}}{{$arg.Name}}{{end}}))
	{{range $i, $ret := $f.Returns}}ret{{$i}}, {{end}}err := wlgen.Service.{{$f.Name}}(ctx{{range $i, $arg := $f.Arguments}}, {{$arg.Name}}{{end}})
	if err != nil {
		fmt.Printf(" = error\n")
		return err
	} else {
		fmt.Printf(" = %v\n", toString({{range $i, $ret := $f.Returns}}{{if $i}}, {{end}}ret{{$i}}{{end}}))
	}
	return nil
}
{{end}}



`
