package goproc

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/blueprint"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/process"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/process/procgen"
	"golang.org/x/exp/slog"
	"golang.org/x/mod/modfile"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

/*
goproc.Process is a node that represents a runnable Golang process.  It can contain any number of
other golang.Node IRNodes.  When it's compiled, the goproc.Process will generate a go module with
a runnable main method that instantiates and initializes the contained go nodes.  To achieve this,
the golang.Process also collects module dependencies from its contained nodes.

The `GenerateArtifacts` method generates the main method based on the process's contained nodes.

Most of the heavy lifting of code generation is done by the following:
* gogen/workspacebuilder
* gogen/modulebuilder
* gogen/graphbuilder

*/

var generatedModulePrefix = "blueprint/goproc"

func init() {
	/* any unattached golang nodes will be instantiated in a "default" golang workspace */
	blueprint.RegisterDefaultBuilder[golang.Node](buildDefaultGolangWorkspace)
}

// An IRNode representing a golang process.
// This is Blueprint's main implementation of Golang processes
type Process struct {
	blueprint.IRNode
	process.Node
	process.ProvidesProcessArtifacts
	process.InstantiableProcess

	InstanceName   string
	ProcName       string
	ModuleName     string
	ArgNodes       []blueprint.IRNode
	ContainedNodes []blueprint.IRNode
}

// A Golang Process Node can either be given the child nodes ahead of time, or they can be added using AddArtifactNode / AddCodeNode
func newGolangProcessNode(name string) *Process {
	node := Process{}
	node.InstanceName = name
	node.ProcName = blueprint.CleanName(name)
	node.ModuleName = generatedModulePrefix + "/" + node.ProcName
	return &node
}

func (node *Process) Name() string {
	return node.InstanceName
}

func (node *Process) String() string {
	var b strings.Builder
	b.WriteString(node.InstanceName)
	b.WriteString(" = GolangProcessNode(")
	var args []string
	for _, arg := range node.ArgNodes {
		args = append(args, arg.Name())
	}
	b.WriteString(strings.Join(args, ", "))
	b.WriteString(") {\n")
	var children []string
	for _, child := range node.ContainedNodes {
		children = append(children, child.String())
	}
	b.WriteString(blueprint.Indent(strings.Join(children, "\n"), 2))
	b.WriteString("\n}")
	return b.String()
}

func (node *Process) AddArg(argnode blueprint.IRNode) {
	node.ArgNodes = append(node.ArgNodes, argnode)
}

func (node *Process) AddChild(child blueprint.IRNode) error {
	node.ContainedNodes = append(node.ContainedNodes, child)
	return nil
}

type mainArg struct {
	Name string
	Doc  string
	Var  string
}

type mainTemplateArgs struct {
	Name             string
	GraphPackage     string
	GraphConstructor string
	Args             []mainArg
	Instantiate      []string
}

var mainTemplate = `// This file is auto-generated by the Blueprint goproc plugin
package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/signal"
	"strings"

	"{{.GraphPackage}}"
	"golang.org/x/exp/slog"
)

var missingArgs []string
func checkArg(name, value string) {
	if value == "" {
		missingArgs = append(missingArgs, name)
	} else {
		slog.Info(fmt.Sprintf("%v = %v", name, value))
	}
}

func main() {
	slog.Info("Running {{.Name}}")
	{{- range $i, $arg := .Args}}
	{{$arg.Var}} := flag.String("{{$arg.Name}}", "", "Argument automatically generated from Blueprint IR: {{$arg.Doc}}")
	{{end}}

	flag.Parse()

	{{range $i, $arg := .Args -}}
	checkArg("{{$arg.Name}}", *{{$arg.Var}})
	{{end}}
	if len(missingArgs) > 0 {
		slog.Error(fmt.Sprintf("Missing required arguments: \n  %v", strings.Join(missingArgs, "\n  ")))
		os.Exit(1)
	}
	
	graphArgs := map[string]string{
		{{- range $i, $arg := .Args}}
		"{{$arg.Name}}": *{{$arg.Var}},
		{{- end}}
	}

	ctx, cancel := context.WithCancel(context.Background())
	graph, err := {{.GraphConstructor}}(ctx, cancel, graphArgs, nil, "{{.Name}}")
	if err != nil {
		slog.Error(err.Error())
		return
	}

	var node any
	{{range $i, $node := .Instantiate -}}
	if err = graph.Get("{{$node}}", &node); err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
	{{end}}
	
	signals := make(chan os.Signal, 1)
	signal.Notify(signals, os.Interrupt)
	go func() {
		for sig := range signals {
			slog.Info(fmt.Sprintf("{{.Name}} received %v\n", sig))
			cancel()
		}
	}()

	graph.WaitGroup().Wait()

	slog.Info("{{.Name}} exiting")
}`

func (node *Process) AddProcessArtifacts(builder process.ProcWorkspaceBuilder) error {
	if builder.Visited(node.Name()) {
		return nil
	}

	// Create the workspace dir

	outputDir, err := builder.CreateProcessDir(node.ProcName)
	if err != nil {
		return err
	}
	return node.generateArtifacts(outputDir, true)
}

func (node *Process) generateArtifacts(outputDir string, generateMain bool) error {
	// Create subdirectory for the golang workspace
	workspaceDir := filepath.Join(outputDir, node.ProcName)
	slog.Info(fmt.Sprintf("Building goproc %s to %s", node.Name(), workspaceDir))
	workspace, err := gogen.NewWorkspaceBuilder(workspaceDir)
	if err != nil {
		return err
	}

	// Add relevant nodes to the workspace
	for _, node := range node.ContainedNodes {
		if n, valid := node.(golang.ProvidesModule); valid {
			if err := n.AddToWorkspace(workspace); err != nil {
				return err
			}
		}
	}

	// Create the module
	slog.Info(fmt.Sprintf("Creating module %v", node.ModuleName))
	module, err := gogen.NewModuleBuilder(workspace, node.ModuleName)
	if err != nil {
		return err
	}

	// Add and/or generate interfaces
	for _, node := range node.ContainedNodes {
		if n, valid := node.(golang.ProvidesInterface); valid {
			if err := n.AddInterfaces(module); err != nil {
				return err
			}
		}
	}

	// Generate constructors and function declarations
	for _, node := range node.ContainedNodes {
		if n, valid := node.(golang.GeneratesFuncs); valid {
			if err := n.GenerateFuncs(module); err != nil {
				return err
			}
		}
	}

	// Create the method to instantiate the graph
	graphFileName := strings.ToLower(node.ProcName) + ".go"
	procPackage := "goproc"
	constructorName := "New" + cases.Title(language.BritishEnglish).String(node.ProcName)
	graph, err := gogen.NewGraphBuilder(module, graphFileName, procPackage, constructorName)
	if err != nil {
		return err
	}

	// Add constructor invocations
	for _, node := range node.ContainedNodes {
		if n, valid := node.(golang.Instantiable); valid {
			if err := n.AddInstantiation(graph); err != nil {
				return err
			}
		}
	}

	// TODO: it's possible some metadata / address nodes are residing in this namespace.  They don't
	// get passed in as args, but need to be added to the graph nonetheless

	// Generate the graph code
	if err = graph.Build(); err != nil {
		return err
	}

	// Generate the main.go
	// By default, main.go will be generated
	// However, it is not generated if the goproc is being built by the default
	// process builder (vs. within a container)
	if generateMain {
		mainArgs := mainTemplateArgs{
			Name:             node.Name(),
			GraphPackage:     fmt.Sprintf("%s/%s", module.Name, procPackage),
			GraphConstructor: fmt.Sprintf("%s.%s", procPackage, constructorName),
			Args:             nil,
			Instantiate:      nil,
		}
		for _, arg := range node.ArgNodes {
			mainArgs.Args = append(mainArgs.Args, mainArg{
				Name: arg.Name(),
				Doc:  arg.String(),
				Var:  blueprint.CleanName(arg.Name()),
			})
		}
		// For now explicitly instantiate every child node
		for _, child := range node.ContainedNodes {
			if _, isInstantiable := child.(golang.Instantiable); isInstantiable {
				mainArgs.Instantiate = append(mainArgs.Instantiate, child.Name())
			}
		}

		slog.Info(fmt.Sprintf("Generating %v/main.go", module.Name))
		mainFileName := filepath.Join(module.ModuleDir, "main.go")
		err = gogen.ExecuteTemplateToFile("goprocMain", mainTemplate, mainArgs, mainFileName)
		if err != nil {
			return err
		}
	}

	return workspace.Finish()
}

type runFuncTemplateArgs struct {
	Name           string
	GoWorkspaceDir string
	GoMainFile     string
	Args           []blueprint.IRNode
}

var runFuncTemplate = `
function run_{{RunFuncName .Name}} {
	export $CGO_ENABLED=1
	cd {{.GoWorkspaceDir}}
	go run {{.GoMainFile}}
	{{- range $i, $arg := .Args}} --{{$arg.Name}}={{EnvVarName $arg.Name}}{{end}}
	{{EnvVarName .Name}}=$!
	return $?
}`

func (node *Process) AddProcessInstance(builder process.ProcGraphBuilder) error {
	if builder.Visited(node.InstanceName) {
		return nil
	}

	mainFile, err := node.findMainFile(builder)
	if err != nil {
		return err
	}

	workspacePath := builder.Info().Workspace.Path
	procDir := filepath.Join(workspacePath, node.ProcName)
	mainFilePath, err := filepath.Rel(procDir, mainFile)
	if err != nil {
		return err
	}

	templateArgs := runFuncTemplateArgs{
		Name:           node.InstanceName,
		GoWorkspaceDir: filepath.ToSlash(procDir),
		GoMainFile:     filepath.ToSlash(mainFilePath),
	}

	runfunc, err := procgen.ExecuteTemplate("rungoproc", runFuncTemplate, templateArgs)
	if err != nil {
		return err
	}

	return builder.DeclareRunCommand(node.InstanceName, runfunc, node.ArgNodes...)
}

/*
If the Blueprint application contains any floating golang nodes, they get
built by this function.
*/
func buildDefaultGolangWorkspace(outputDir string, nodes []blueprint.IRNode) error {
	proc := newGolangProcessNode("default")
	proc.ContainedNodes = nodes
	return proc.generateArtifacts(outputDir, false)
}

func (node *Process) findMainFile(builder process.ProcGraphBuilder) (string, error) {
	goWorkspaceDir := filepath.Join(builder.Info().Workspace.Path, node.ProcName)
	entries, err := os.ReadDir(goWorkspaceDir)
	if err != nil {
		return "", err
	}
	for _, e := range entries {
		if e.IsDir() {
			modDir := filepath.Join(goWorkspaceDir, e.Name())
			modFileName := filepath.Join(modDir, "go.mod")
			modFileData, err := os.ReadFile(modFileName)
			if err != nil {
				continue
			}
			f, err := modfile.Parse(modFileName, modFileData, nil)
			if err != nil {
				continue
			}
			if f.Module.Mod.Path == node.ModuleName {
				return filepath.Join(modDir, "main.go"), nil
			}
		}
	}
	return "", blueprint.Errorf("unable to find main.go file for golang process %v", node.InstanceName)
}
