package retries

import (
	"fmt"
	"path/filepath"

	"github.com/blueprint-uservices/blueprint/plugins/golang"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gocode"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gogen"
	"golang.org/x/exp/slog"
)

// code generation function called from the ir.go file.
func generateClient(builder golang.ModuleBuilder, wrapped *gocode.ServiceInterface, outputPackage string, Max int64) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	client := clientArgs{
		Package: pkg,
		Service: wrapped,
		Name:    wrapped.BaseName + "_RetrierClient",
		Max:     Max,
		Imports: gogen.NewImports(pkg.Name),
	}

	client.Imports.AddPackages("context")

	return generateClientCommon(&client, clientTemplate)
}

func generateExpBackoffClient(builder golang.ModuleBuilder, wrapped *gocode.ServiceInterface, outputPackage string, delay string, limit string, useJitter bool) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	client := clientArgs{
		Package:   pkg,
		Service:   wrapped,
		Name:      wrapped.BaseName + "_RetrierExpBackoffClient",
		Imports:   gogen.NewImports(pkg.Name),
		Delay:     delay,
		Limit:     limit,
		UseJitter: useJitter,
	}

	client.Imports.AddPackages("context", "time")

	return generateClientCommon(&client, clientExponentialBackoffTemplate)
}

func generateFixedDelayClient(builder golang.ModuleBuilder, wrapped *gocode.ServiceInterface, outputPackage string, max_tries int64, delay string) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	client := clientArgs{
		Package: pkg,
		Service: wrapped,
		Name:    wrapped.BaseName + "_RetrierFixedDelayClient",
		Imports: gogen.NewImports(pkg.Name),
		Delay:   delay,
		Max:     max_tries,
	}

	client.Imports.AddPackages("context", "time")

	return generateClientCommon(&client, clientFixedDelayTemplate)
}

func generateRateLimiterClient(builder golang.ModuleBuilder, wrapped *gocode.ServiceInterface, outputPackage string, Max int64, RetryRateLimit int64) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	client := clientArgs{
		Package:        pkg,
		Service:        wrapped,
		Name:           wrapped.BaseName + "_RetrierRateLimiterClient",
		Max:            Max,
		RetryRateLimit: RetryRateLimit,
		Imports:        gogen.NewImports(pkg.Name),
	}

	client.Imports.AddPackages("context", "time")

	return generateClientCommon(&client, clientRateLimiterTemplate)
}

func generateClientCommon(client *clientArgs, clientTemplate string) error {
	clientName := client.Name
	slog.Info(fmt.Sprintf("Generating %v/%v", client.Package.PackageName, clientName))
	outputFile := filepath.Join(client.Package.Path, clientName+".go")

	if client.UseJitter {
		client.Imports.AddPackages("math/rand")
	}

	return gogen.ExecuteTemplateToFile("Retries", clientTemplate, client, outputFile)
}

type clientArgs struct {
	Package   golang.PackageInfo
	Service   *gocode.ServiceInterface
	Name      string
	Max       int64
	Delay     string
	Limit     string
	UseJitter bool
	Imports   *gogen.Imports
}

var clientTemplate = `// Blueprint: Auto-generated by Retries Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Client {{.Imports.NameOf .Service.UserType}}
	MaxTries int
}

func New_{{.Name}} (ctx context.Context, client {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Client = client
	handler.MaxTries = {{.Max}}
	return handler, nil
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{ range $_, $f := .Service.Methods }}
func (client *{{$receiver}}) {{$f.Name -}} ({{ArgVarsAndTypes $f "ctx context.Context"}}) ({{RetVarsAndTypes $f "err error"}}) {
	for i := 0; i < client.MaxTries; i++ {
		{{RetVars $f "err"}} = client.Client.{{$f.Name}}({{ArgVars $f "ctx"}})
		if err == nil {
			return
		}
	}
	return
}
{{end}}
`

var clientFixedDelayTemplate = `// Blueprint: Auto-generated by Retries Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Client {{.Imports.NameOf .Service.UserType}}
	MaxTries int
	Delay time.Duration
}

func New_{{.Name}} (ctx context.Context, client {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Client = client
	handler.MaxTries = {{.Max}}
	dur := "{{.Delay}}"
	parsed_dur, err := time.ParseDuration(dur)
	if err != nil {
		return nil, err
	}
	handler.Delay = parsed_dur
	return handler, nil
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{ range $_, $f := .Service.Methods }}
func (client *{{$receiver}}) {{$f.Name -}} ({{ArgVarsAndTypes $f "ctx context.Context"}}) ({{RetVarsAndTypes $f "err error"}}) {
	for i := 0; i < client.MaxTries; i++ {
		{{RetVars $f "err"}} = client.Client.{{$f.Name}}({{ArgVars $f "ctx"}})
		if err == nil {
			return
		}
		time.Sleep(client.Delay)
	}
	return
}
{{end}}
`

var clientExponentialBackoffTemplate = `// Blueprint: Auto-generated by Retries Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Client {{.Imports.NameOf .Service.UserType}}
	Delay time.Duration
	Limit time.Duration
    {{if .UseJitter -}}
    Rand *rand.Rand
    {{- end}}
}

func New_{{.Name}} (ctx context.Context, client {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Client = client
	parsed_delay, err := time.ParseDuration("{{.Delay}}")
	if err != nil {
		return nil, err
	}
	handler.Delay = parsed_delay
	parsed_limit, err := time.ParseDuration("{{.Limit}}")
	if err != nil {
		return nil, err
	}
	handler.Limit = parsed_limit
    
	{{if .UseJitter -}}
    handler.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))
    {{- end}}

	return handler, nil
}

{{if .UseJitter}}
func (client *{{.Name}}) addJitter(d time.Duration) time.Duration {
    return d/2 + time.Duration(client.Rand.Int63n(int64(d/2)))
}
{{end}}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{$useJitter := .UseJitter -}}
{{ range $_, $f := .Service.Methods }}
func (client *{{$receiver}}) {{$f.Name}}({{ArgVarsAndTypes $f "ctx context.Context"}}) ({{RetVarsAndTypes $f "err error"}}) {
    delay := client.Delay
    for {
        {{RetVars $f "err"}} = client.Client.{{$f.Name}}({{ArgVars $f "ctx"}})
        if err == nil {
            return
        }
        
        {{if $useJitter -}}
        sleepDuration := client.addJitter(delay)
        {{else -}}
        sleepDuration := delay
        {{end}}
        
        select {
        case <-time.After(sleepDuration):
            // Continue with next attempt
        case <-ctx.Done():
            {{if $f.Returns -}}
            return {{RetVars $f "ctx.Err()"}}
            {{else -}}
            return ctx.Err()
            {{end -}}
        }
        
        delay *= 2
        if delay > client.Limit {
            delay = client.Limit
        }
    }
}
{{end}}
`

var clientRateLimiterTemplate = `// Blueprint: Auto-generated by Retries Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Client {{.Imports.NameOf .Service.UserType}}
	MaxTries int
	// rateLimit is the maximum number of retries per second
	tokens float64
	maxTokens float64
	refillRate float64
	lastRefill time.Time
}

func New_{{.Name}} (ctx context.Context, client {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Client = client
	handler.MaxTries = {{.Max}}
	// rateLimit is the maximum number of retries per second
	rateLimit := float64({{.RetryRateLimit}})
	handler.tokens = rateLimit
	handler.maxTokens = rateLimit
	handler.refillRate = rateLimit
	handler.lastRefill = time.Now()
	return handler, nil
}

// waitForToken blocks until a token is available or context is cancelled
func (client *{{.Name}}) waitForToken(ctx context.Context) error {
	for {
		if client.acquireToken() {
			return nil
		}
		
		// Wait a bit and try again
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(time.Millisecond * 10):
			continue
		}
	}
}

// acquireToken implements token bucket algorithm
func (client *{{.Name}}) acquireToken() bool {
	now := time.Now()
	elapsed := now.Sub(client.lastRefill).Seconds()
	
	// Add tokens based on elapsed time
	client.tokens += elapsed * client.refillRate
	if client.tokens > client.maxTokens {
		client.tokens = client.maxTokens
	}
	client.lastRefill = now
	
	// Try to consume a token
	if client.tokens >= 1.0 {
		client.tokens--
		return true
	}
	
	return false
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{ range $_, $f := .Service.Methods }}
func (client *{{$receiver}}) {{$f.Name -}} ({{ArgVarsAndTypes $f "ctx context.Context"}}) ({{RetVarsAndTypes $f "err error"}}) {
	// First attempt - no rate limiting
	{{RetVars $f "err"}} = client.Client.{{$f.Name}}({{ArgVars $f "ctx"}})
	if err == nil {
		return
	}
	
	// Retry attempts with rate limiting
	for i := 1; i < client.MaxTries; i++ {
		// Wait for rate limit token
		waitErr := client.waitForToken(ctx)
		if waitErr == nil {
			// Call the original method
			{{RetVars $f "err"}} = client.Client.{{$f.Name}}({{ArgVars $f "ctx"}})
			if err == nil {
				return
			}
		} else {
			err = waitErr
		}
	}

	return
}
{{end}}
`
