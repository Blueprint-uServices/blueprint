package healthchecker

import (
	"fmt"
	"path/filepath"
	"reflect"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/blueprint"
	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/core/service"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gocode"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
	"golang.org/x/exp/slog"
)

type HealthCheckerServerWrapper struct {
	golang.Service
	golang.GeneratesFuncs
	golang.Instantiable

	InstanceName string
	Wrapped      golang.Service

	outputPackage   string
	methodInterface HealthCheckerInterface
}

type HealthCheckerInterface struct {
	*gocode.ServiceInterface
	Wrapped service.ServiceInterface
}

func (i *HealthCheckerInterface) GetName() string {
	return "healthcheck(" + i.Wrapped.GetName() + ")"
}

func (i *HealthCheckerInterface) GetMethods() []service.Method {
	methods := i.Wrapped.GetMethods()
	health_check_method := &gocode.Func{}
	health_check_method.Arguments = append(health_check_method.Arguments, gocode.Variable{Name: "ctx", Type: &gocode.UserType{Package: "context", Name: "Context"}})
	health_check_method.Returns = append(health_check_method.Returns, gocode.Variable{Type: &gocode.BasicType{Name: "error"}})
	methods = append(methods, health_check_method)
	return methods
}

func (node *HealthCheckerServerWrapper) ImplementsGolangNode() {}

func (node *HealthCheckerServerWrapper) Name() string {
	return node.InstanceName
}

func (node *HealthCheckerServerWrapper) String() string {
	return node.Name() + " = HealthCheckerServerWrapper(" + node.Wrapped.Name() + ")"
}

func newHealthCheckerServerWrapper(name string, server blueprint.IRNode) (*HealthCheckerServerWrapper, error) {
	serverNode, is_callable := server.(golang.Service)
	if !is_callable {
		return nil, fmt.Errorf("healthchecker server wrapper requires %s to be a golang service but got %s", server.Name(), reflect.TypeOf(server).String())
	}

	node := &HealthCheckerServerWrapper{}
	node.InstanceName = name
	node.Wrapped = serverNode
	node.outputPackage = "healthcheck"

	return node, nil
}

func (node *HealthCheckerServerWrapper) GetInterface() service.ServiceInterface {
	node.methodInterface = HealthCheckerInterface{Wrapped: node.Wrapped.GetInterface()}
	return &node.methodInterface
}

func (node *HealthCheckerServerWrapper) GenerateFuncs(builder golang.ModuleBuilder) error {
	service, valid := node.Wrapped.GetInterface().(*gocode.ServiceInterface)
	if !valid {
		return blueprint.Errorf("expected %v to have a gocode.ServiceInterface but got %v", node.Name(), node.Wrapped.GetInterface())
	}
	err := generateServerHandler(builder, service, node.outputPackage)
	if err != nil {
		return err
	}
	return nil
}

func (node *HealthCheckerServerWrapper) AddInstantiation(builder golang.GraphBuilder) error {
	// Only generate instantiation code for this instance once
	if builder.Visited(node.InstanceName) {
		return nil
	}

	service, valid := node.Wrapped.GetInterface().(*gocode.ServiceInterface)
	if !valid {
		return blueprint.Errorf("expected %v to have a gocode.ServiceInterface but got %v", node.Name(), node.Wrapped.GetInterface())
	}

	constructor := &gocode.Constructor{
		Package: builder.Module().Info().Name + "/" + node.outputPackage,
		Func: gocode.Func{
			Name: fmt.Sprintf("New_%v_HealthCheckerHandler", service.Name),
			Arguments: []gocode.Variable{
				{Name: "service", Type: service},
			},
		},
	}

	return builder.DeclareConstructor(node.InstanceName, constructor, []blueprint.IRNode{node.Wrapped})
}

func generateServerHandler(builder golang.ModuleBuilder, service *gocode.ServiceInterface, outputPackage string) error {
	// TODO: Implement
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	server := &serverArgs{
		Package: pkg,
		Service: service,
		Name:    service.Name + "_HealthCheckHandler",
		Imports: gogen.NewImports(pkg.Name),
	}

	server.Imports.AddPackages("context")

	slog.Info(fmt.Sprintf("Generating %v/%v_HealthChecker.go", server.Package.PackageName, service.Name))
	outputFile := filepath.Join(server.Package.Path, service.Name+"_HealthChecker.go")
	return gogen.ExecuteTemplateToFile("HealthChecker", serverTemplate, server, outputFile)
}

type serverArgs struct {
	Package golang.PackageInfo
	Service *gocode.ServiceInterface
	Name    string
	Imports *gogen.Imports
}

var serverTemplate = `// Blueprint: Auto-generated by HealthChecker Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Service {{.Imports.NameOf .Service.UserType}}
}

func New_{{.Name}}(service {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Service = service
	return handler, nil
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{ range $_, $f := .Service.Methods }}
func (handler *{{$receiver}}) {{$f.Name -}} (ctx context.Context, {{ArgVars $f}}) ({{RetVars $f}}, error) {
	return handler.Service.{{$f.Name}}({{ArgVars $f "ctx"}})
}
{{end}}
`
