package parser2

import (
	"fmt"
	"strings"
)

// /*
// Stripped back representations of golang modules, packages, structs, and interfaces, that expose the minimal information
// currently needed for Golang-related Blueprint plugins.

// The workflow spec plugin constructs much of this information by parsing the workflow spec's AST.

// Other plugins will often extend the information provided to them by other nodes, e.g. a wrapped node that extends
// an interface will simply create a new interface with additional arguments.
// */

/* Module, version, and package that contains a definition */
type Source struct {
	ModuleName    string
	ModuleVersion string
	PackageName   string
}

type Variable struct {
	Name string
	Type TypeName
}

func (v Variable) String() string {
	if v.Name == "" {
		return v.Type.String()
	} else {
		return fmt.Sprintf("%v %v", v.Name, v.Type)
	}
}

type Func struct {
	Name      string
	Arguments []Variable
	Returns   []Variable
}

func (f Func) String() string {
	var arglist []string
	for _, arg := range f.Arguments {
		arglist = append(arglist, arg.String())
	}
	args := strings.Join(arglist, ", ")
	var retlist []string
	for _, ret := range f.Returns {
		retlist = append(retlist, ret.String())
	}
	rets := strings.Join(retlist, ", ")
	if len(f.Returns) > 1 {
		return fmt.Sprintf("func %v(%v) (%v)", f.Name, args, rets)
	} else if len(f.Returns) == 1 {
		return fmt.Sprintf("func %v(%v) %v", f.Name, args, rets)
	} else {
		return fmt.Sprintf("func %v(%v)", f.Name, args)
	}
}

type Constructor struct {
	Func
	Source
}

type Service struct {
	Source
	Name    string
	Methods map[string]Func
}

// type Module interface {
// }

// type ExternalModule struct {
// 	Module
// 	Name    string // Fully qualified module name
// 	Version string
// }

// type LocalModule struct {
// 	Module
// 	Name    string // Fully qualified module name
// 	Version string
// 	Replace string // Replacement path to local directory
// }

// type Package interface {
// 	GetModule() Module
// }

// // A user-defined package that will need to import a module to be used
// type UserPackage struct {
// 	Package
// 	Module Module
// 	Name   string // Fully qualified package name
// }

// func (pkg *UserPackage) GetModule() Module {
// 	return pkg.Module
// }

// // A package that is generated by a plugin and thus doesn't necessarily have a fully qualified name yet
// type PluginGeneratedPackage struct {
// 	Package
// 	Name   string // short name of package
// 	Plugin string // plugin generating it
// }

// func (pkg *PluginGeneratedPackage) GetModule() Module {
// 	return nil
// }

// // A builtin package like "os" or "context"
// type BuiltinPackage struct {
// 	Package
// 	Name string
// }

// func (pkg *BuiltinPackage) GetModule() Module {
// 	return nil
// }

// type Type interface {

// 	/* The packages that must be imported in order to use this type */
// 	Packages() []Package

// 	/* The module dependencies that must be required in go.mod to use this type */
// 	Modules() []Module
// }

// type UserType struct {
// 	Type
// 	Package Package
// 	Name    string // Type name from within the imported package
// }

// func (typ *UserType) Packages() []Package {
// 	return []Package{typ.Package}
// }

// func (typ *UserType) Modules() []Module {
// 	mod := typ.Package.GetModule()
// 	if mod == nil {
// 		return nil
// 	} else {
// 		return []Module{mod}
// 	}
// }

// type BasicType struct {
// 	Type
// 	Name string // e.g. "int64", "string" etc.
// }

// func (typ *BasicType) Packages() []Package {
// 	return nil
// }

// func (typ *BasicType) Modules() []Module {
// 	return nil
// }

// // TODO: array, pointer, func etc. types

// // The type signature of a func
// type FuncType struct {
// 	Type
// 	Args []Type
// 	Rets []Type
// }

// func (typ *FuncType) Packages() []Package {
// 	var pkgs []Package
// 	for _, arg := range typ.Args {
// 		pkgs = append(pkgs, arg.Packages()...)
// 	}
// 	for _, arg := range typ.Rets {
// 		pkgs = append(pkgs, arg.Modules()...)
// 	}
// 	return pkgs
// }

// func (typ *FuncType) GetModules() []Module {
// 	var mods []Module
// 	for _, arg := range typ.Args {
// 		mods = append(mods, arg.Modules()...)
// 	}
// 	for _, arg := range typ.Rets {
// 		mods = append(mods, arg.Modules()...)
// 	}
// 	return mods
// }

// // A named argument to a func implementation
// type FuncArg struct {
// 	Name string
// 	Type Type
// }

// // A func implementation with no receiver; different from FuncType
// type Constructor struct {
// 	Package Package   // Package containing the function
// 	Name    string    // Function name
// 	Args    []FuncArg // arguments have names
// 	Rets    []Type    // rets lack names.  Rets should be validated before creation, to ensure it returns an instance or instance + error
// }

// // A method of an interface
// type Method struct {
// 	Name string
// 	Args []FuncArg // arguments have names
// 	Rets []Type    // rets lack names
// }

// type Interface struct {
// 	Type    UserType
// 	Methods []Method
// }

// // Represents a service.  This struct should contain enough information for:
// //   - knowing the packages and modules where all relevant types are defined
// //   - knowing the interface for plugins to extend, and argument / retval types
// //   - know the function to invoke to instantiate it
// //   - know the interface type, for typecasting
// type Service struct {
// 	Interface   Interface   // TODO: support multiple interfaces
// 	Constructor Constructor // TODO: support constructor overloading
// }
