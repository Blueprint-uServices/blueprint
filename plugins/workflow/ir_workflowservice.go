package workflow

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/blueprint-uservices/blueprint/blueprint/pkg/coreplugins/service"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/ir"
	"github.com/blueprint-uservices/blueprint/plugins/golang"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gogen"
	"github.com/blueprint-uservices/blueprint/plugins/golang/goparser"
	"golang.org/x/exp/slog"
)

// This Node represents a Golang Workflow spec service in the Blueprint IR.
type workflowNode struct {
	// IR node types
	golang.Service

	InstanceName string // Name of this instance
	ServiceType  string // The short-name serviceType used to initialize this workflow service

	// Details of the service, including its interface and constructor
	ServiceInfo *WorkflowSpecService

	// The workflow spec where this service originated
	Spec *WorkflowSpec
}

// The client-side of a workflow service
type workflowClient struct {
	workflowNode

	Wrapped ir.IRNode // The next client
}

// The server-side of a workflow service
type workflowHandler struct {
	workflowNode

	// IR Nodes of arguments that will be passed in to the generated code
	Args []ir.IRNode
}

func (n *workflowNode) Init(name, serviceType string) error {
	// Look up the service details; errors out if the service doesn't exist
	spec, err := GetSpec()
	if err != nil {
		return err
	}

	details, err := spec.Get(serviceType)
	if err != nil {
		return err
	}

	n.InstanceName = name
	n.ServiceType = serviceType
	n.ServiceInfo = details
	n.Spec = spec

	return nil
}

func (node *workflowNode) Name() string {
	return node.InstanceName
}

func (node *workflowNode) GetInterface(ctx ir.BuildContext) (service.ServiceInterface, error) {
	return node.ServiceInfo.Iface.ServiceInterface(ctx), nil
}

// Both the client and the handler need to add interfaces to modules that use them.
func (node *workflowNode) AddInterfaces(builder golang.ModuleBuilder) error {
	return node.AddToWorkspace(builder.Workspace())
}

// Client and handler side both need to add the service interface to the output
func (node *workflowNode) AddToWorkspace(builder golang.WorkspaceBuilder) error {
	// Add blueprint runtime to the workspace
	if err := golang.AddRuntimeModule(builder); err != nil {
		return err
	}

	// Add interface module to workspace
	if _, err := copyModuleToOutputWorkspace(builder, node.ServiceInfo.Iface.File.Package.Module); err != nil {
		return err
	}

	return nil
}

// The handler node needs to add the constructor package to the output
func (node *workflowHandler) AddToWorkspace(builder golang.WorkspaceBuilder) error {
	// Add the service interface and runtime package
	if err := node.workflowNode.AddToWorkspace(builder); err != nil {
		return err
	}

	// Add constructor module to workspace
	if _, err := copyModuleToOutputWorkspace(builder, node.ServiceInfo.Constructor.File.Package.Module); err != nil {
		return err
	}

	return nil
}

func copyModuleToOutputWorkspace(b golang.WorkspaceBuilder, mod *goparser.ParsedModule) (string, error) {
	_, subdir := filepath.Split(mod.SrcDir)
	if !b.Visited(mod.Name) {
		slog.Info(fmt.Sprintf("Copying local module %v to workspace", subdir))
	}
	return b.AddLocalModule(subdir, mod.SrcDir)
}

func (node *workflowHandler) AddInstantiation(builder golang.NamespaceBuilder) error {
	// Only generate instantiation code for this instance once
	if builder.Visited(node.InstanceName) {
		return nil
	}

	slog.Info(fmt.Sprintf("Instantiating %v %v in %v/%v", node.ServiceType, node.InstanceName, builder.Info().Package.PackageName, builder.Info().FileName))
	return builder.DeclareConstructor(node.InstanceName, node.ServiceInfo.Constructor.AsConstructor(), node.Args)
}

type workflowClientTemplateArgs struct {
	ServiceType string
	WrappedName string
}

func (node *workflowClient) AddInstantiation(builder golang.NamespaceBuilder) error {
	// Only generate instantiation code for this instance once
	if builder.Visited(node.InstanceName) {
		return nil
	}

	template := `func(n *golang.Namespace) (any, error) {
		// Auto-generated by the golang plugin workflow/ir_workflowservice.go
		var client {{.ServiceType}}
		err := n.Get("{{.WrappedName}}", &client)
		return client, err
	}`

	templateArgs := &workflowClientTemplateArgs{
		ServiceType: builder.ImportType(node.ServiceInfo.Iface.Type()),
		WrappedName: node.Wrapped.Name(),
	}

	// template := fmt.Sprintf(`func(n *golang.Namespace) (any, error) {
	// 	// Auto-generated by the golang plugin workflow/ir_workflowservice.go
	// 	var client any
	// 	return n.Get("%s")
	// }`, node.Wrapped.Name())

	slog.Info(fmt.Sprintf("Instantiating %v %v in %v/%v", node.ServiceType, node.InstanceName, builder.Info().Package.PackageName, builder.Info().FileName))

	code, err := gogen.ExecuteTemplate("workflowClient.AddInstantiation", template, templateArgs)
	if err != nil {
		return err
	}

	return builder.Declare(node.InstanceName, code)
}

func (n *workflowClient) String() string {
	var b strings.Builder
	b.WriteString(n.InstanceName)
	b.WriteString(" = ")
	b.WriteString(n.Wrapped.Name())

	return b.String()
}

func (n *workflowHandler) String() string {
	var b strings.Builder
	b.WriteString(n.InstanceName)
	b.WriteString(" = ")
	b.WriteString(n.ServiceInfo.Iface.Name)

	var args []string
	for _, arg := range n.Args {
		args = append(args, arg.Name())
	}

	b.WriteString("(")
	b.WriteString(strings.Join(args, ", "))
	b.WriteString(")")

	return b.String()
}

func (node *workflowNode) ImplementsGolangNode()    {}
func (node *workflowNode) ImplementsGolangService() {}
