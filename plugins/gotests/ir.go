package gotests

import (
	"fmt"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/ir"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
	"golang.org/x/exp/slog"
)

type TestLibrary struct {
	ir.ArtifactGenerator

	LibraryName    string
	ModuleName     string
	ArgNodes       []ir.IRNode
	ContainedNodes []ir.IRNode
	ServicesToTest []ir.IRNode
}

func newTestLibrary(name string) *TestLibrary {
	node := TestLibrary{}
	node.LibraryName = name
	node.ModuleName = "blueprint/testclients"
	return &node
}

func (lib *TestLibrary) Name() string {
	return lib.LibraryName
}

func (lib *TestLibrary) String() string {
	return ir.PrettyPrintNamespace(lib.LibraryName, "GolangTests", lib.ArgNodes, lib.ContainedNodes)
}

/*
Generates a golang workspace to a directory on the local filesystem.

Within the workspace will have converted all compatible unit tests into
tests that can be run against the generated Blueprint system.  The
generated Blueprint system must be running for the tests to work.
*/
func (lib *TestLibrary) GenerateArtifacts(workspaceDir string) error {
	slog.Info(fmt.Sprintf("Generating unit tests to %s", workspaceDir))
	workspace, err := gogen.NewWorkspaceBuilder(workspaceDir)
	if err != nil {
		return err
	}

	// Add relevant nodes to the workspace
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.ProvidesModule); valid {
			if err := n.AddToWorkspace(workspace); err != nil {
				return err
			}
		}
	}

	// Create a module for the clients
	slog.Info(fmt.Sprintf("Creating client library %v", lib.ModuleName))
	module, err := gogen.NewModuleBuilder(workspace, lib.ModuleName)
	if err != nil {
		return err
	}

	// Add and/or generate client interfaces
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.ProvidesInterface); valid {
			if err := n.AddInterfaces(module); err != nil {
				return err
			}
		}
	}

	// Generate constructors and function declarations
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.GeneratesFuncs); valid {
			if err := n.GenerateFuncs(module); err != nil {
				return err
			}
		}
	}

	// Create the method to instantiate the namespace
	namespaceFileName := "clients.go"
	procPackage := "goproc"
	constructorName := "NewClientLibraryForTests"
	namespaceBuilder, err := gogen.NewNamespaceBuilder(module, "gotests", namespaceFileName, procPackage, constructorName)
	if err != nil {
		return err
	}

	// Add constructor invocations
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.Instantiable); valid {
			if err := n.AddInstantiation(namespaceBuilder); err != nil {
				return err
			}
		}
	}

	// All arg nodes are optional for a client library, since the caller might only be using
	// a subset of the client nodes.
	for _, node := range lib.ArgNodes {
		namespaceBuilder.OptionalArg(node.Name(), fmt.Sprintf("Argument generated by Blueprint IR: %v", node))
	}

	// Client library doesn't eagerly instantiate any nodes

	// Generate the namespace code
	if err = namespaceBuilder.Build(); err != nil {
		return err
	}

	for _, node := range lib.ServicesToTest {
		iface, err := golang.GetGoInterface(module, node)
		if err != nil {
			return err
		}
		fmt.Printf("got iface for %v: \n%v\n", node.Name(), iface)
	}

	// TODO: update the tests
	//  * copy the test lib to the output
	//  * for the services under test, get their interface
	//  * parse code to find registry for these service types
	//  * add file to package containing the specific test

	// Complete workspace generation
	return workspace.Finish()
}
