package gotests

import (
	"fmt"
	"path/filepath"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/ir"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/goparser"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/gotests/codegen"
	"golang.org/x/exp/slog"
)

// An IR node that:
//   - creates a golang workspace with all client library code
//   - copies tests from the source application to the output
//   - modifies tests to register the generated clients
type testLibrary struct {
	ir.ArtifactGenerator

	LibraryName    string
	ModuleName     string
	ArgNodes       []ir.IRNode
	ContainedNodes []ir.IRNode
	ServicesToTest map[string]ir.IRNode
}

func newTestLibrary(name string, argNodes, containedNodes []ir.IRNode, servicesToTest map[string]ir.IRNode) *testLibrary {
	node := &testLibrary{
		LibraryName:    name,
		ModuleName:     "blueprint/testclients",
		ArgNodes:       argNodes,
		ContainedNodes: containedNodes,
		ServicesToTest: servicesToTest,
	}
	return node
}

func (lib *testLibrary) Name() string {
	return lib.LibraryName
}

func (lib *testLibrary) String() string {
	return ir.PrettyPrintNamespace(lib.LibraryName, "GolangTests", lib.ArgNodes, lib.ContainedNodes)
}

/*
Generates a golang workspace to a directory on the local filesystem.

Within the workspace will have converted all compatible unit tests into
tests that can be run against the generated Blueprint system.  The
generated Blueprint system must be running for the tests to work.
*/
func (lib *testLibrary) GenerateArtifacts(workspaceDir string) error {
	slog.Info(fmt.Sprintf("Generating unit tests to %s", workspaceDir))
	workspace, err := gogen.NewWorkspaceBuilder(workspaceDir)
	if err != nil {
		return err
	}

	// Add relevant nodes to the workspace
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.ProvidesModule); valid {
			if err := n.AddToWorkspace(workspace); err != nil {
				return err
			}
		}
	}

	// Create a module for the clients
	slog.Info(fmt.Sprintf("Creating client library %v", lib.ModuleName))
	module, err := gogen.NewModuleBuilder(workspace, lib.ModuleName)
	if err != nil {
		return err
	}

	// Add and/or generate client interfaces
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.ProvidesInterface); valid {
			if err := n.AddInterfaces(module); err != nil {
				return err
			}
		}
	}

	// Generate constructors and function declarations
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.GeneratesFuncs); valid {
			if err := n.GenerateFuncs(module); err != nil {
				return err
			}
		}
	}

	// Create the method to instantiate the namespace
	namespaceFileName := "clients.go"
	procPackage := "clients"
	constructorName := "NewClientLibrary"
	namespaceBuilder, err := gogen.NewNamespaceBuilder(module, "clients", namespaceFileName, procPackage, constructorName)
	if err != nil {
		return err
	}

	// Add constructor invocations
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.Instantiable); valid {
			if err := n.AddInstantiation(namespaceBuilder); err != nil {
				return err
			}
		}
	}

	// All arg nodes are optional for a client library, since the caller might only be using
	// a subset of the client nodes.
	for _, node := range lib.ArgNodes {
		namespaceBuilder.OptionalArg(node.Name(), fmt.Sprintf("Argument generated by Blueprint IR: %v", node))
	}

	// Client library doesn't eagerly instantiate any nodes

	// Generate the namespace code
	if err = namespaceBuilder.Build(); err != nil {
		return err
	}

	// Modify the tests

	// Find all registry.ServiceRegistry variables declared in the workflow spec code
	r, err := findWorkflowServiceRegistries()
	if err != nil {
		return err
	}

	// Find the ones that match the services we want to test and generate additional test initialization code
	builders := make(map[string]*codegen.ClientBuilder)

	namespacePackage := namespaceBuilder.Package.PackageName
	namespaceConstructor := namespaceBuilder.Package.ShortName + "." + constructorName
	namespaceName := "tests"

	for name, node := range lib.ServicesToTest {
		// Find the interface type
		iface, err := golang.GetGoInterface(module, node)
		if err != nil {
			return err
		}

		// Find registries of that type
		registries := r.Get(iface)
		if len(registries) == 0 {
			slog.Warn(fmt.Sprintf("Cannot test %v due to no instances found of registry.ServiceRegistry[%v]", name, iface.UserType.String()))
			continue
		}

		// Group registries by package, because we will generate one file per package that has tests
		for _, reg := range registries {
			slog.Info(fmt.Sprintf("Test registry %v for %v (%v) found in %v", reg.VarName, name, reg.RegistryOf, reg.Var.File.Name))

			pkg := reg.Var.File.Package

			if _, exists := builders[pkg.Name]; !exists {
				// The first time we see a package, create a builder
				moduleDir, err := copyModuleToOutputWorkspace(workspace, pkg.Module)
				if err != nil {
					return err
				}

				// One client builder gets created per package with tests
				packageDir := filepath.Join(moduleDir, reg.Var.File.PathInModule)
				builders[pkg.Name] = codegen.NewClientBuilder(pkg.Name, pkg.ShortName, namespaceConstructor, namespacePackage, namespaceName, packageDir)
			}

			// Add the client to the builder
			builders[pkg.Name].AddClient(reg.VarName, name, node.Name(), reg.RegistryOf)
		}
	}

	// Do the codegen
	for _, b := range builders {
		err = b.Build()
		if err != nil {
			return err
		}
	}

	// Complete workspace generation
	return workspace.Finish()
}

func copyModuleToOutputWorkspace(b golang.WorkspaceBuilder, mod *goparser.ParsedModule) (string, error) {
	_, subdir := filepath.Split(mod.SrcDir)
	if !b.Visited(mod.Name) {
		slog.Info(fmt.Sprintf("Copying local module %v to workspace", subdir))
	}
	return b.AddLocalModule(subdir, mod.SrcDir)
}
