package gotests

import (
	"fmt"
	"path/filepath"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint/pkg/ir"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/golang/gogen"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/gotests/codegen"
	"gitlab.mpi-sws.org/cld/blueprint/plugins/workflow"
	"golang.org/x/exp/slog"
)

type TestLibrary struct {
	ir.ArtifactGenerator

	LibraryName    string
	ModuleName     string
	ArgNodes       []ir.IRNode
	ContainedNodes []ir.IRNode
	ServicesToTest map[string]ir.IRNode
}

func newTestLibrary(name string) *TestLibrary {
	node := TestLibrary{}
	node.LibraryName = name
	node.ModuleName = "blueprint/testclients"
	node.ServicesToTest = make(map[string]ir.IRNode)
	return &node
}

func (lib *TestLibrary) Name() string {
	return lib.LibraryName
}

func (lib *TestLibrary) String() string {
	return ir.PrettyPrintNamespace(lib.LibraryName, "GolangTests", lib.ArgNodes, lib.ContainedNodes)
}

/*
Generates a golang workspace to a directory on the local filesystem.

Within the workspace will have converted all compatible unit tests into
tests that can be run against the generated Blueprint system.  The
generated Blueprint system must be running for the tests to work.
*/
func (lib *TestLibrary) GenerateArtifacts(workspaceDir string) error {
	slog.Info(fmt.Sprintf("Generating unit tests to %s", workspaceDir))
	workspace, err := gogen.NewWorkspaceBuilder(workspaceDir)
	if err != nil {
		return err
	}

	// Add relevant nodes to the workspace
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.ProvidesModule); valid {
			if err := n.AddToWorkspace(workspace); err != nil {
				return err
			}
		}
	}

	// Create a module for the clients
	slog.Info(fmt.Sprintf("Creating client library %v", lib.ModuleName))
	module, err := gogen.NewModuleBuilder(workspace, lib.ModuleName)
	if err != nil {
		return err
	}

	// Add and/or generate client interfaces
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.ProvidesInterface); valid {
			if err := n.AddInterfaces(module); err != nil {
				return err
			}
		}
	}

	// Generate constructors and function declarations
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.GeneratesFuncs); valid {
			if err := n.GenerateFuncs(module); err != nil {
				return err
			}
		}
	}

	// Create the method to instantiate the namespace
	namespaceFileName := "clients.go"
	procPackage := "clients"
	constructorName := "NewClientLibrary"
	namespaceBuilder, err := gogen.NewNamespaceBuilder(module, "clients", namespaceFileName, procPackage, constructorName)
	if err != nil {
		return err
	}

	// Add constructor invocations
	for _, node := range lib.ContainedNodes {
		if n, valid := node.(golang.Instantiable); valid {
			if err := n.AddInstantiation(namespaceBuilder); err != nil {
				return err
			}
		}
	}

	// All arg nodes are optional for a client library, since the caller might only be using
	// a subset of the client nodes.
	for _, node := range lib.ArgNodes {
		namespaceBuilder.OptionalArg(node.Name(), fmt.Sprintf("Argument generated by Blueprint IR: %v", node))
	}

	// Client library doesn't eagerly instantiate any nodes

	// Generate the namespace code
	if err = namespaceBuilder.Build(); err != nil {
		return err
	}

	// Modify the tests

	// Find all registry.ServiceRegistry variables declared in the workflow spec code
	r, err := FindWorkflowServiceRegistries()
	if err != nil {
		return err
	}

	// Find the ones that match the services we want to test and generate additional test initialization code
	for name, node := range lib.ServicesToTest {
		// Find the interface type
		iface, err := golang.GetGoInterface(module, node)
		if err != nil {
			return err
		}

		// Find registries of that type
		registries := r.Get(&iface.UserType)
		if len(registries) == 0 {
			slog.Warn(fmt.Sprintf("Cannot test %v due to no instances found of registry.ServiceRegistry[%v]", name, iface.UserType))
		} else {
			for _, reg := range registries {
				slog.Info(fmt.Sprintf("Test registry %v for %v (%v) found in %v", reg.VarName, name, reg.RegistryOf, reg.Var.File.Name))

				// Include the registry's source module in the output
				moduleDir, err := workflow.CopyModuleToOutputWorkspace(workspace, reg.Var.File.Package.Module)
				if err != nil {
					return err
				}

				// Generate the init function, which will create and add the service client to the tests
				packageDir := filepath.Join(moduleDir, reg.Var.File.PathInModule)
				packageName := reg.Var.File.Package.Name
				packageShortName := reg.Var.File.Package.ShortName
				registryVar := reg.VarName
				clientName := name
				nodeToInstantiate := node.Name()
				clientType := reg.RegistryOf

				namespacePackage := namespaceBuilder.Package.PackageName
				namespaceConstructor := namespaceBuilder.Package.ShortName + "." + constructorName

				err = codegen.AddClientToTests(packageDir, packageName, packageShortName, registryVar, clientName, nodeToInstantiate, clientType)
				if err != nil {
					return err
				}
			}
		}
	}

	// Complete workspace generation
	return workspace.Finish()
}
