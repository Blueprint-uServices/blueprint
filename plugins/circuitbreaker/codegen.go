package circuitbreaker

import (
	"fmt"
	"path/filepath"

	"github.com/blueprint-uservices/blueprint/plugins/golang"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gocode"
	"github.com/blueprint-uservices/blueprint/plugins/golang/gogen"
	"golang.org/x/exp/slog"
)

func generateClient(builder golang.ModuleBuilder, wrapped *gocode.ServiceInterface, outputPackage string, MinReqs int64, FailureRate float64, Interval string) error {
	pkg, err := builder.CreatePackage(outputPackage)
	if err != nil {
		return err
	}

	client := clientArgs{
		Package:     pkg,
		Service:     wrapped,
		Name:        wrapped.BaseName + "_CircuitBreakerClient",
		MinReqs:     MinReqs,
		FailureRate: FailureRate,
		Interval:    Interval,
		Imports:     gogen.NewImports(pkg.Name),
	}

	client.Imports.AddPackages("context", "time", "github.com/mercari/go-circuitbreaker")

	slog.Info(fmt.Sprintf("Generating %v/%v", client.Package.PackageName, wrapped.BaseName+"CircuitBreakerClient"))
	outputFile := filepath.Join(client.Package.Path, wrapped.BaseName+"_CircuitBreakerClient.go")
	return gogen.ExecuteTemplateToFile("CircuitBreaker", clientTemplate, client, outputFile)
}

type clientArgs struct {
	Package     golang.PackageInfo
	Service     *gocode.ServiceInterface
	Name        string
	MinReqs     int64
	FailureRate float64
	Interval    string
	Imports     *gogen.Imports
}

var clientTemplate = `// Blueprint: Auto-generated by CircuitBreaker Plugin
package {{.Package.ShortName}}

{{.Imports}}

type {{.Name}} struct {
	Client {{.Imports.NameOf .Service.UserType}}
	MinReqs int64
	FailureRate float64
	cb *circuitbreaker.CircuitBreaker
}

func New_{{.Name}} (ctx context.Context, client {{.Imports.NameOf .Service.UserType}}) (*{{.Name}}, error) {
	handler := &{{.Name}}{}
	handler.Client = client
	handler.MinReqs = {{.MinReqs}}
	handler.FailureRate = {{.FailureRate}}

	dur, err := time.ParseDuration("{{.Interval}}")
	if err != nil {
		return nil, err
	}

	cb := circuitbreaker.New(
		circuitbreaker.WithFailOnContextCancel(true),
		circuitbreaker.WithFailOnContextDeadline(true),
		circuitbreaker.WithCounterResetInterval(dur),
		circuitbreaker.WithTripFunc(circuitbreaker.NewTripFuncFailureRate(handler.MinReqs,handler.FailureRate)),
	)
	handler.cb = cb

	return handler, nil
}

{{$service := .Service.Name -}}
{{$receiver := .Name -}}
{{ range $_, $f := .Service.Methods }}
func (client *{{$receiver}}) {{$f.Name -}} ({{ArgVarsAndTypes $f "ctx context.Context"}}) ({{RetVarsAndTypes $f "err error"}}) {
	if !client.cb.Ready() {
		err = circuitbreaker.ErrOpen
		return
	}
	defer func() { err = client.cb.Done(ctx, err)}()
	return client.Client.{{$f.Name}}({{ArgVars $f "ctx"}})
}
{{end}}
`
