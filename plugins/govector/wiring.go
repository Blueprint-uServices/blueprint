// Package govector provides a Blueprint plugin for collecting log messages from services using the GoVector vector clock logging library.  GoVector is a vector clock logging library developed for educational purposes by researchers at UBC Systopia.  More information on [GoVector]. This plugin provides APIs to be used by the wiring spec to do the following:
//
//  1. to wrap the client and server side of a service with a GoVector wrapper to maintain and propagate vector clocks for each process. A vector clock is a logical clock maintained by every process in a distributed system which can then be used to establish partial order between distributed operations. The plugin generates a log file for each process where the incremental vector timestamps are stored to track the propagation of requests.
//  2. to install a GoVector logger for a given process. The log messages are appended with vector timestamps and added to a log file in chronological order. Log files from all processes can be combined to visualize the full execution of a distributed system.
//
// # Wiring Usage
//
// To instrument the service to correctly propagate vector clocks:
//
//	govector.Instrument(spec, service)
//
// To instantiate a process's vector clock and to redirect a process's logging statements to GoVector:
//
//	govector.Logger(spec, proc)
//
// # Artifacts generated
//
//  1. Generates client and server side wrappers for instrumented services that contain govector instrumentation (vector clock per process, vector clock propagation)
//
// # Runtime Output
//
// At runtime, a log file called `proc_name.goveclogger-Log.txt` will be generated for each process (with name `proc_name`) and placed in that process's directory. Here is a sample generated log entry from a generated log file:
//
//	nonleaf_process_logger.goveclogger {"nonleaf_process_logger.goveclogger":1}
//	Initialization Complete
//
// # Full Wiring Example:
//
// The following example instruments all services with govector and uses the govector logger in all processes.
//
//	func applyGoVectorOptions() {
//		for _, service := range serviceNames {
//			govector.Instrument(spec, service) // Instrument the service to propagate vector clocks
//		}
//		for _, proc := range procNames {
//			logger := govector.Logger(spec, proc) // Define a logger for the process
//		}
//	}
//
// See the [govector_logger] wiring spec for the Leaf application for a more concrete example.
//
// # Viewing Logs
//
// The log files generated by GoVector plugin can be converted into a single log file using the [GoVector] command line tool which can then be visualized using the [ShiViz] visualization tool. Instructions for converting log files to a ShiViz compatible log file are as follows:
//
//	go install github.com/DistributedClocks/GoVector
//	GoVector --log_type shiviz --log_dir path/to/logs --outfile out.log
//
// Sample log files generated using the [govector_logger] wiring specification for Blueprint's leaf application can be found at [govector leaf logs].
//
// [GoVector]: https://github.com/DistributedClocks/GoVector
// [govector_logger]: https://github.com/Blueprint-uServices/blueprint/tree/main/examples/leaf/wiring/specs/govector.go
// [govector leaf logs]: https://github.com/Blueprint-uServices/blueprint/tree/main/plugins/govector/example_logs
// [ShiViz]: https://bestchai.bitbucket.io/shiviz/
package govector

import (
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/blueprint"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/coreplugins/pointer"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/ir"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/wiring"
	"github.com/blueprint-uservices/blueprint/plugins/golang"
	"github.com/blueprint-uservices/blueprint/plugins/goproc"
	"golang.org/x/exp/slog"
)

// [Instrument] can be used by the wiring specs to instrument the client and server side of a service with govector-instrumentation to initialize, maintain, and propagate vector clocks.
// The instrumentation generates logging events appended with vector clock timestamps.
// Ensures that the logs are sent to a GoVector logger defined with name `logger`
//
// # Wiring Spec Usage
//
//	govector.Instrument(spec, "my_service")
func Instrument(spec wiring.WiringSpec, serviceName string) {
	clientWrapper := serviceName + ".client.govec"
	serverWrapper := serviceName + ".server.govec"

	ptr := pointer.GetPointer(spec, serviceName)
	if ptr == nil {
		slog.Error("Unable to deploy " + serviceName + " using GoVector as it is not a pointer")
	}

	clientNext := ptr.AddSrcModifier(spec, clientWrapper)

	spec.Define(clientWrapper, &GovecClientWrapper{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		var wrapped golang.Service
		if err := ns.Get(clientNext, &wrapped); err != nil {
			return nil, blueprint.Errorf("GoVector client %s expected %s to be a golang.Service, but encountered %s", clientWrapper, clientNext, err)
		}
		return newGovecClientWrapper(clientWrapper, wrapped)
	})

	serverNext := ptr.AddDstModifier(spec, serverWrapper)

	spec.Define(serverWrapper, &GovecServerWrapper{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		var wrapped golang.Service
		if err := ns.Get(serverNext, &wrapped); err != nil {
			return nil, blueprint.Errorf("GoVector server %s expected %s to be a golang.Service, but encountered %s", serverWrapper, serverNext, wrapped)
		}
		return newGovecServerWrapper(serverWrapper, wrapped)
	})
}

// [Logger] can be used by the wiring specs to install a govector logger for process with name `procName`.
// Replaces the existing installed logger for the process.
//
// A process with name `procName` must be defined before this function is called.
//
// # Wiring Spec Usage
//
//	govector.Logger(spec, "my_process")
func Logger(spec wiring.WiringSpec, procName string) string {
	logger := procName + ".goveclogger" // Logger names must be unique across the system
	spec.Define(logger, &GoVecLoggerClient{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		return newGoVecLoggerClient(logger)
	})
	goproc.SetLogger(spec, procName, logger)
	return logger
}
