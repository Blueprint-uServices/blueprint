package goprocess

// This is used to accumulate code that is generated by golang instances
type GolangCodeAccumulator struct {
	packages map[string]string // Packages that will be included in the generated go.mod as 'require {package} {version}
	code     map[string]string // Code that has been auto-generated and will be included as generated output
	files    map[string]string // Code that will be copied into the generated output
}

func NewGolangCodeAccumulator() *GolangCodeAccumulator {
	gc := GolangCodeAccumulator{}
	gc.packages = make(map[string]string)
	gc.code = make(map[string]string)
	gc.files = map[string]string{}
	return &gc
}

// Adds a dependency to the specified package and version to the generated code
// Can return an error if there are conflicting version dependencies
func (cg *GolangCodeAccumulator) AddModule(pkg, version string) error {
	// TODO: implement
	return nil
}

// Adds generated code at the specified path in the output
func (cg *GolangCodeAccumulator) AddCode(path, code string) error {
	// TODO: implement
	// If code or file already exists at the path, log a warning
	return nil
}

// Copies a file to the path specified
func (cg *GolangCodeAccumulator) AddFile(path, inputpath string) error {
	// TODO implement
	// If code or file already exists at the path, log a warning, although that might be legit behavior if a plugin wants to read-modify-write an existing code file
	return nil
}

// This is called by the compiler after nodes have added their code, to write output
func (cg *GolangCodeAccumulator) GenerateOutput(path string) error {
}
